{"version":3,"file":"5898.bundle.1a70998ac9eced2978fb.js","mappings":"wHASaA,EAQXC,WAAAA,CAAYC,GACVC,KAAKC,SAAWF,CACjB,CAQDG,YAAAA,GAEE,MAAMC,EAAaH,KAAKC,SAASG,UAAU,EAAG,IACxCC,EAAaL,KAAKC,SAASG,UAAU,GAAI,IAGzCE,EAAOC,SAASJ,EAAWC,UAAU,EAAG,GAAI,IAC5CI,EACJL,EAAWM,QAAU,EACjBF,SAASJ,EAAWC,UAAU,EAAG,GAAI,SACrCM,EACAC,EACJR,EAAWM,QAAU,GACjBF,SAASJ,EAAWC,UAAU,EAAG,IAAK,SACtCM,EAEN,GACEE,MAAMN,SACEI,IAAPF,GAAoBI,MAAMJ,SACnBE,IAAPC,GAAoBC,MAAMD,IAC3BL,EAAO,KACNE,IAAOA,EAAK,GAAKA,EAAK,KACtBG,IAAOA,EAAK,GAAKA,EAAK,IAEvB,MAAM,IAAIE,MAAJ,iBAA2BV,MAGnC,MAAMW,EAAS,IAAIC,KAAJ,GAAYZ,sBAGrBa,EAAKT,SAASF,EAAWD,UAAU,EAAG,GAAI,IAC1Ca,EACJZ,EAAWI,QAAU,EACjBF,SAASF,EAAWD,UAAU,EAAG,GAAI,SACrCM,EACAQ,EACJb,EAAWI,QAAU,EACjBF,SAASF,EAAWD,UAAU,EAAG,GAAI,SACrCM,EACAS,EAAgBd,EAAWD,UAAU,EAAG,IACxCgB,EAASD,EACXZ,SAASY,EAAe,IAAME,KAAKC,IAAI,IAAKH,EAAcV,aAC1DC,EAEJ,GACEE,MAAMI,SACEN,IAAPO,GAAoBL,MAAMK,SACnBP,IAAPQ,GAAoBN,MAAMM,SACfR,IAAXU,GAAwBR,MAAMQ,IAC/BJ,EAAK,GACLA,EAAK,IACJC,IAAOA,EAAK,GAAKA,EAAK,KACtBC,IAAOA,EAAK,GAAKA,EAAK,KACtBE,IAAWA,EAAS,GAAKA,EAAS,QAEnC,MAAM,IAAIP,MAAJ,iBAA2BR,MAGnC,IAAIkB,EAAYT,EAAOU,UAAY,IAanC,OAXAD,GAAkB,KAALP,OACFN,IAAPO,IACFM,GAAkB,GAALN,QAEJP,IAAPQ,IACFK,GAAaL,QAEAR,IAAXU,IACFG,GAAaH,GAGRG,CACR,CAQDE,iBAAAA,GAEE,OAD6C,IAAtBzB,KAAKE,cAE7B,E,SAeqBwB,EACtB3B,EACA4B,GAEA,MAAMC,EAAQ,GAAGD,EAAKC,OAAS,OAAOC,SAAS,EAAG,KAC5CC,EAAU,GAAGH,EAAKG,SAAW,OAAOD,SAAS,EAAG,KAChDE,EAAU,GAAGJ,EAAKI,SAAW,OAAOF,SAAS,EAAG,KAChDG,EAAQ,GAAGjC,EAAKiC,QAAQH,SAAS,EAAG,KACpCI,EAAM,GAAGlC,EAAKkC,MAAMJ,SAAS,EAAG,KAChCK,EAAoB,GAAGP,EAAKO,mBAAqB,WAAWC,OAChE,EACA,KAEIhC,EAAa,GAAGJ,EAAKqC,QAAQJ,KAASC,IAI5C,OAAO,IAAIpC,EAFY,GAAGM,IADP,IAAIyB,KAASE,KAAWC,KAAWG,OAIvD,CCrFD,SAAwBG,EAAQtC,GAC9B,GACEA,SAEgB,IAAhBA,EAAKU,QACW,iBAATV,EAEP,MAAM,IAAIc,MAAJ,eAAyBd,MAGjC,MAAMO,EAAOC,SAASR,EAAKK,UAAU,EAAG,GAAI,IACtCI,EAAKD,SAASR,EAAKK,UAAU,EAAG,GAAI,IACpCO,EAAKJ,SAASR,EAAKK,UAAU,EAAG,GAAI,IAE1C,IAAkC,IAzCfkC,EAyCH3B,EAzCc4B,EAyCV/B,EAzCqBgC,EAyCjBlC,GAvCpBM,MAAM4B,IAIHD,EAAI,GAAKA,GAAK,IAAMD,EAAI,GAAKA,GA7BtC,SAAqBC,EAAWC,GAE9B,OAAQD,GACN,KAAK,EACH,OAAQC,EAAI,GAAM,GAAKA,EAAI,KAAQA,EAAI,KAAQ,EAAI,GAAK,GAC1D,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,GACH,OAAO,GACT,QACE,OAAO,GAEZ,CAgB0CC,CAAYF,EAAGC,IAoCtD,MAAM,IAAI3B,MAAJ,eAAyBd,MA1CnC,IAAqBuC,EAAWC,EAAWC,EA6CzC,MAAO,CACLJ,KAAM9B,EACN0B,MAAOxB,EACPyB,IAAKtB,EAER,CC/DD,SAAwB+B,EAAQf,GAC9B,GACEA,SAEAA,EAAKlB,OAAS,GACE,iBAATkB,EAGP,MAAM,IAAId,MAAJ,eAAyBc,MAKjC,MAAMgB,EAAKpC,SAASoB,EAAKvB,UAAU,EAAG,GAAI,IACpCI,EAAKmB,EAAKlB,QAAU,EAAIF,SAASoB,EAAKvB,UAAU,EAAG,GAAI,SAAMM,EAC7DkC,EAAKjB,EAAKlB,QAAU,EAAIF,SAASoB,EAAKvB,UAAU,EAAG,GAAI,SAAMM,EAC7DS,EAAgBQ,EAAKlB,QAAU,EAAIkB,EAAKvB,UAAU,EAAG,SAAMM,EAC3DmC,EAAS1B,EACXZ,SAASY,EAAe,IAAME,KAAKC,IAAI,GAAI,EAAIH,EAAcV,aAC7DC,EAEJ,GACEE,MAAM+B,SACEjC,IAAPF,GAAoBI,MAAMJ,SACnBE,IAAPkC,GAAoBhC,MAAMgC,SACflC,IAAXmC,GAAwBjC,MAAMiC,IAC/BF,EAAK,GACLA,EAAK,IACJnC,IAAOA,EAAK,GAAKA,EAAK,KACtBoC,IAAOA,EAAK,GAAKA,EAAK,KACtBC,IAAWA,EAAS,GAAKA,EAAS,QAEnC,MAAM,IAAIhC,MAAJ,eAAyBc,MAGjC,MAAO,CACLC,MAAOe,EACPb,QAAStB,EACTuB,QAASa,EACTV,kBAAmBW,EAEtB,CChDD,SAAwBC,EACtBC,GAEA,GAAIA,QACF,MAAM,IAAIlC,MAAM,uDAKlB,OAAOa,EAFMW,EAAQU,EAAS3C,UAAU,EAAG,IAC9BsC,EAAQK,EAAS3C,UAAU,IAEzC,CCaD,SAAS4C,EAAyBC,GAChC,MAAM,sBACJC,EADI,qBAEJC,EAFI,iCAGJC,EAHI,6BAIJC,EAJI,WAKJC,GACEL,EAAU,GAEd,GAAIC,QACF,MAAM,IAAIrC,MACR,qEAIJ,GAAIsC,QACF,MAAM,IAAItC,MACR,oEAIJ,MAAM0C,ECvBR,SACEN,GAEA,MAAM,WACJK,EADI,WAEJE,EAFI,+BAGJC,GACER,EAAU,GACRS,EAAU,IAAIC,MAAMV,EAAUxC,QAG9BmD,EAAoClC,EAFRW,EAAQiB,GACRZ,EAAQc,IAM1C,IAAIK,EAA8B,IAAIhE,EAAJ,+BAG9BiE,EAAYD,EAA4B3D,eAsB5C,GArBA+C,EAAUc,SAAQC,IAChB,MAAM,gBAAEC,EAAF,gBAAmBC,GAAoBF,EAIvCG,EAAyCzC,EAFRW,EAAQ4B,GACRvB,EAAQwB,IAO7CL,EADEA,EAA4B3D,gBAAkB4D,GAI9CK,EAAoBjE,eACpB2D,EAA4B3D,eAJAiE,EAMxBN,CACP,IAGCA,EAA4B3D,gBAAkB4D,EAChD,MAAM,IAAIjD,MAAM,0DAGlB,OACE+C,EAAe1D,gBAAkB2D,EAA4B3D,eAEtDwD,EAAQU,KAAKR,GAEhBH,EAEKC,EAAQU,KACbtB,EAA4BW,IAevBC,EAAQU,KAAKP,EAoEzB,CDjHwCQ,CAAmBpB,GACpDqB,EExCR,SAA2CC,GAKzC,MAAM,iCACJnB,EADI,6BAEJC,EAFI,WAGJC,GACEiB,EAEJ,IAAI5C,EACA5B,EACJ,GAAIqD,EACF,OAAON,EAA4BM,GAC9B,GAAIC,GAAgCC,EAOzC,OAHA3B,EAAOe,EAAQW,GACftD,EAAOsC,EAAQiB,GAER5B,EAAgB3B,EAAM4B,GAG/B,MAAM,IAAId,MAAJ,kBAA4B0D,IACnC,CFcsCC,CAAmB,CACtDpB,mCACAC,+BACAC,eAGF,OAAOL,EAAUwB,KAAI,CAACC,EAAGC,KACvB,MACMC,EADWrB,EAAUoB,GAEhBzE,eAAiBoE,EAAUpE,eACtC,GAAI0E,EAAiB,EACnB,MAAM,IAAI/D,MAAM,uCAOlB,OAAO,GAHLqC,EACA7B,KAAKC,IAAI,GAAIsD,EAAiBzB,GAEhC,GAEH,CAQD,MAAM0B,EAAa,CACjBC,EACAC,IAGED,IAAMC,GACLpB,MAAMqB,QAAQF,IACbnB,MAAMqB,QAAQD,IACdD,EAAErE,SAAWsE,EAAEtE,QACfqE,EAAEG,OAAM,CAACC,EAAKP,IAAUO,IAAQH,EAAEJ,KAcxC,SAAwBQ,EACtBlC,GAEA,MAAM,eACJmC,EADI,MAEJC,EAFI,uBAGJC,EAHI,cAIJC,EAJI,WAKJC,EALI,YAMJC,GACExC,EAAU,GAEd,IAAKmC,EAAeM,SAAS,UAAYN,EAAeM,SAAS,QAC/D,MAAM,IAAI7E,MAAJ,kDAC8CuE,KAsBtD,IAfuBnC,EAAUgC,OAAMjB,GAEnCA,EAASqB,QAAUA,GACnBR,EAAWb,EAASoB,eAAgBA,IACpCpB,EAASuB,gBAAkBA,GAC3BvB,EAASwB,aAAeA,GACxBxB,EAASyB,cAAgBA,GACzBzB,EAASb,uBAAyBF,EAAU,GAAGE,sBAC/Ca,EAASd,wBAA0BD,EAAU,GAAGC,uBAChDc,EAAS2B,kBAAoB1C,EAAU,GAAG0C,iBAC1C3B,EAASV,aAAeL,EAAU,GAAGK,YACrCU,EAASR,aAAeP,EAAU,GAAGO,aAKvC,MAAM,IAAI3C,MACR,gJAKJ,IAAK0E,EACH,MAAM,IAAI1E,MACR,mFAIJ,IAAI+E,EAAiC,IAAIjC,MAAMV,EAAUxC,QACzDmF,EAAuB5C,EAAyBC,GAEhD,IAAIS,EAAoB,IAAIC,MAAMV,EAAUxC,QAC5C,MAAMoF,EAAwC,IAAhBN,EAE9B,GAAc,SAAVF,EACF3B,EAAUkC,EAAqBnB,KAAI,SAASqB,GAC1C,OAAOA,EAAQD,CAChB,SACI,GAAc,SAAVR,EAAkB,CAC3B,MAAMU,EAAkC9C,EAAUgC,OAAMjB,I,UACtD,OACEA,EAASsB,wBAC2C,QAApD,UAAAtB,EAASsB,8BAAT,eAAiCU,sBACmBtF,KAApD,UAAAsD,EAASsB,8BAAT,eAAiCU,iBACmB,KAApD,UAAAhC,EAASsB,8BAAT,eAAiCU,eAJnC,IAQIC,EAAoDhD,EAAUgC,OAClEjB,I,UACE,OACEA,EAASsB,0BACT,UAACtB,EAASsB,8BAAV,OAAC,EAAiCU,sBAEhCtF,KADF,UAAAsD,EAASsB,8BAAT,eAAiCY,mCAG/B,KADF,UAAAlC,EAASsB,8BAAT,eAAiCY,iCALnC,IAcJ,GAAIH,EACFrC,EAAUT,EAAUwB,KAGlBT,GAAYA,EAASsB,uBAAwBU,qBAE1C,KAAIC,EAaT,MAAM,IAAIpF,MAAJ,qEACiEsF,KAAKC,UACxEd,MAZJ5B,EAAUT,EAAUwB,KAAI,CAACT,EAAUW,IAI/BX,EAASsB,uBAAwBY,iCACjCN,EAAqBjB,GACrBkB,GASL,CACF,KAAM,IAAc,QAAVR,EAIT,MAAM,IAAIxE,MAAJ,+BAAyCwE,KAF/C3B,EAAQU,KAAK,EAGd,CAGD,IAAIiC,EAeAC,EACAC,EAfJ,GAAId,QACFe,QAAQC,KACN,yFAEG,CAMLJ,EGjOJ,SACEK,GAEA,MAAM,cAAEnB,EAAF,YAAiBE,GAAgBiB,EAKvC,OAFErF,KAAKC,IAAIiE,EAAe,MAASlE,KAAKC,IAAkB,IAAdmE,EAAmB,MAAS,KAGzE,CHwNkBkB,CAL6B,CAC1CpB,gBACAE,eAIH,CAKD,GAAIA,QACFe,QAAQC,KACN,0FAEG,GAAIjB,QACTgB,QAAQC,KACN,wFAEG,CACL,MAAMG,EAAyC,CAC7CrB,gBACAC,aACAC,eAGFa,EIrPJ,SACEI,GAEA,MAAM,WAAElB,EAAF,cAAcD,EAAd,YAA6BE,GAAgBiB,EAEnD,IAAIG,EACJ,MAAMC,EAAmBzF,KAAKC,IAAIiE,GAA+B,IAAdE,GAAoB,GAEvE,GAAmB,MAAfD,EACFqB,EAAM,KAAOtB,EAAgB,IAAMuB,MAC9B,IAAmB,MAAftB,EAGT,MAAM,IAAI3E,MAAJ,mCAA6C2E,KAFnDqB,EAAM,IAAMtB,EAAgB,IAAMuB,CAGnC,CAED,OAAa,IAAND,CACR,CJoOkBE,CAA6BH,GAC5CL,EI5NJ,SACEG,GAEA,MAAM,WAAElB,EAAF,cAAcD,EAAd,YAA6BE,GAAgBiB,EAEnD,IAAIG,EACJ,MAAMG,EAAgBzB,EAAgBlE,KAAKC,IAAImE,EAAa,GAE5D,GAAmB,MAAfD,EACFqB,EAAO,KAAOtB,GAAkB,KAAO,IAAMyB,OACxC,IAAmB,MAAfxB,EAGT,MAAM,IAAI3E,MAAJ,mCAA6C2E,KAFnDqB,EAAO,KAAOtB,GAAkB,KAAO,IAAMyB,EAG9C,CACD,OAAa,IAANH,CACR,CJ4MuBI,CAA0CL,EAC/D,CAED,OAAOlD,EAAQe,KAAI,SAASyC,EAAQvC,GAClC,MAAMwC,EAA+B,CACnCC,MAAOF,GAoBT,OAjBIb,IAEFc,EAAQE,OAASzB,EAAqBjB,GAAS0B,GAG7CC,IAEFa,EAAQG,OAAS1B,EAAqBjB,GAAS2B,GAG7CC,IACFY,EAAQI,YAAc3B,EAAqBjB,GAAS4B,GAM/CY,CACR,GACF,C,o+CKtQD,SAASK,EAAmBC,GAE1B,IADA,IAAMC,EAAM,IAAIC,WAAWF,EAAIhH,QACtBmH,EAAI,EAAGC,EAAIJ,EAAIhH,OAAQmH,EAAIC,EAAGD,IACrCF,EAAIE,GAAKH,EAAIK,WAAWF,GAE1B,OAAOF,C,CA2BT,SAASK,EAAcC,EAASC,GAAmB,IAAZC,EAAS,UAAH,6CAAG,EAC9C,GAAIA,EAASD,EAAMxH,OAASuH,EAAQvH,OAClC,OAAO,EAIT,IADA,IAAIkE,EAAQuD,EACHN,EAAI,EAAGA,EAAIK,EAAMxH,OAAQmH,IAAK,CACrC,GAAIK,EAAML,KAAOI,EAAQrD,GACvB,OAAO,EAGTA,GAAS,C,CAEX,OAAO,C,CAUT,SAASwD,EAAUH,EAASC,GAAoC,IAA7BC,EAAS,UAAH,6CAAG,EAAGE,EAAe,uCACxDC,EAAeL,EAAQvH,OACvB2H,IACFC,EAAehH,KAAKiH,IAAIJ,EAASE,EAAiBJ,EAAQvH,SAG5D,IAAK,IAAImH,EAAIM,EAAQN,EAAIS,EAAcT,IAIrC,GAAII,EAAQJ,KAAOK,EAAM,IACnBF,EAAcC,EAASC,EAAOL,GAChC,OAAOA,EAKb,OAAQ,C,CAoCV,SAASW,EACPC,GAGA,IAFAC,EAAW,UAAH,6CA9BV,WACE,SAASC,IACP,OAAOrH,KAAKsH,MAA4B,OAArB,EAAItH,KAAKuH,WACzBC,SAAS,IACTzI,UAAU,E,CAEf,MAAO,GAAP,OAAUsI,IAAOA,IAAI,YAAIA,IAAI,YAAIA,IAAI,YAAIA,IAAI,YAAIA,KAAI,OAAGA,KAAI,OAAGA,I,CAwBpDI,GAGLC,EAAoB,iBAAH,OAFT,UAAH,6CAAG,qBAGRC,EAAS,SAAH,OAAYP,EAAQ,eAAOM,EAAiB,YAClDE,EAAS,SAAH,OAAYR,EAAQ,MAC1BS,EAAc1B,EAAmBwB,GACjCG,EAAc3B,EAAmByB,GACjCG,EAAeF,EAAYzI,OAC3B4I,EAAeF,EAAY1I,OAE7BA,EAAS,EAGP6I,EAAgBd,EAAS/D,KAAI,SAAA8E,GACjC,IAAMC,EAAe,IAAI7B,WAAW4B,GAC9BE,EAAgBD,EAAa/I,OAInC,OAFAA,GAAU2I,EAAeK,EAAgBJ,EAElCG,C,IAIHE,EAAiB,IAAI/B,WAAWlH,GAGtCiJ,EAAeC,IAAIT,EAAa,GAGhC,IAAIU,EAAW,EAUf,OATAN,EAAcvF,SAAQ,SAAAyF,GACpBE,EAAeC,IAAIT,EAAaU,GAChCF,EAAeC,IAAIH,EAAcI,EAAWR,GAE5CQ,GAAYR,EAAeI,EAAa/I,M,IAG1CiJ,EAAeC,IAAIR,EAAaS,GAEzB,CACLC,KAAMH,EAAeI,OACrBrB,SAAAA,E,CAUJ,SAASsB,EAAgBC,GAEvB,IAAMhC,EAAUiC,YAAYC,OAAOF,GAAYA,EAAW,IAAIrC,WAAWqC,GAQnEG,EAAY3C,EAAmB,YAC/B4C,EAAcjC,EAAUH,EAASmC,EAAW,EAJ1B,KAKxB,IAAqB,IAAjBC,EACF,MAAM,IAAIvJ,MAAM,iDAGlB,IAAMmI,EAhMR,SAA4BtB,GAG1B,IAHkD,IAAnBQ,EAAS,UAAH,6CAAG,EAClCmC,GAD0C,yCACrB3C,EAAIjH,OAASyH,EACpCT,EAAM,GACDG,EAAIM,EAAQN,EAAIM,EAASmC,EAAWzC,IAC3CH,GAAO6C,OAAOC,aAAa7C,EAAIE,IAEjC,OAAOH,C,CA0LQ+C,CAAmBxC,EAAS,EAAGoC,GACxCK,EAtKR,SAA0BzB,GAGxB,IAFA,IAAM0B,EAAQ1B,EAAO2B,MAAM,QAElB/C,EAAI,EAAGA,EAAI8C,EAAMjK,OAAQmH,IAChC,GAA8B,OAA1B8C,EAAM9C,GAAGgD,OAAO,EAAG,GACrB,OAAOF,EAAM9C,GAIjB,OAAO,I,CA6JgBiD,CAAiB7B,GACxC,IAAKyB,EACH,MAAM,IAAI5J,MAAM,wDAYlB,IATA,IAOIiK,EAPErC,EAAWjB,EAAmBiD,GAC9BM,EAAiBtC,EAAShI,OAC1BuK,EAAa,GAEf9C,EAAS6C,GAKa,IAAnBD,IAMkB,KAHvBA,EAAgB3C,EAAUH,EAASS,EAAUP,KAHlB,CAU3B,IAAM+C,EAAmB9C,EACvBH,EACAmC,EACAjC,EArCoB,KAwCtB,IAA0B,IAAtB+C,EACF,MAAM,IAAIpK,MAAM,4CAElBqH,EAAS+C,EAAmBd,EAAU1J,OAGtC,IACMoJ,EAAOG,EAASkB,MAAMhD,EAAQ4C,EADd,GAItBE,EAAWG,KAAKtB,GAIhB3B,EAAS4C,EAAgBC,C,CAG3B,OAAOC,C,CCvPT,SAASI,EAASC,GAChB,MAAsB,WAAf,EAAOA,IAA4B,OAARA,C,CAGpC,SAASC,EAAcD,GACrB,OAAmC,IAA5BE,OAAOC,KAAKH,GAAK5K,QAAgB4K,EAAIvL,cAAgByL,M,oBAqB9D,IAAME,EAAiB,SAAAvE,GAAM,OAAIA,EAAO,E,EAElCwE,EAAa,CACjBC,MAAO,oBACPC,WAAY,yBACZC,aAAc,2BACdC,IAAK,kBACLC,KAAM,aACNC,IAAK,aAOHC,EAAW,WAAO,EC3CtB,ICQMC,EAAM,CACVC,eFoDkB,WAiBlB,WAAYC,I,4FAAS,SACnBpM,KAAKqM,QAAUD,EAAQE,IAClBtM,KAAKqM,SACR7F,QAAQ+F,MAAM,sEAGZ,aAAcH,IAChBpM,KAAKwM,SAAWJ,EAAQI,SAClB,aAAcJ,GAClB5F,QAAQ+F,MACN,8DAGJvM,KAAKyM,SAAWL,EAAQK,UAGtB,kBAAmBL,GACrBH,EAAS,+BAAD,OAAgCG,EAAQM,gBAChD1M,KAAK2M,QAAU,GAAH,OAAM3M,KAAKqM,QAAO,YAAID,EAAQM,gBAE1C1M,KAAK2M,QAAU3M,KAAKqM,QAGlB,kBAAmBD,GACrBH,EAAS,+BAAD,OAAgCG,EAAQQ,gBAChD5M,KAAK6M,QAAU,GAAH,OAAM7M,KAAKqM,QAAO,YAAID,EAAQQ,gBAE1C5M,KAAK6M,QAAU7M,KAAKqM,QAGlB,kBAAmBD,GACrBH,EAAS,+BAAD,OAAgCG,EAAQU,gBAChD9M,KAAK+M,QAAU,GAAH,OAAM/M,KAAKqM,QAAO,YAAID,EAAQU,gBAE1C9M,KAAK+M,QAAU/M,KAAKqM,QAGlBD,EAAQY,YACVf,EAAS,iBAAkBG,EAAQY,YACnChN,KAAKgN,YAAoC,IAAvBZ,EAAQY,WAAsB,uBAAyBZ,EAAQY,YAEjFhN,KAAKgN,WAAa,GAGhB,iBAAkBZ,IACpBpM,KAAKiN,aAAeb,EAAQa,cAI9BjN,KAAKkN,QAAUd,EAAQc,SAAW,CAAC,EAGnClN,KAAKmN,iBAAmBf,EAAQe,kBAAqB,W,EAGrDnN,KAAKoN,SAA8B,IAApBhB,EAAQgB,QAEvBpN,KAAKqN,SAASjB,EAAQkB,M,WA+3BvB,O,EA13BD,E,EAAA,kCAOsD,IAA7CC,EAAa,UAAH,8CAAUC,EAAmB,UAAH,6CAAG,KAC9CxN,KAAKuN,aAAeA,EACpBtB,EAAWuB,GAAoBD,EAAa/G,QAAQiH,IAAM,WAAO,C,IAGnE,gCAME,OAAOzN,KAAKuN,U,IAGd,gCAKWH,GACTpN,KAAKoN,QAAUA,C,IAGjB,kCAME,OAAOpN,KAAKoN,O,IACb,mBAaD,eAYad,EAAKoB,GAAoC,WAA5BR,EAAU,UAAH,6CAAG,CAAC,EAAGd,EAAU,UAAH,6CAAG,CAAC,EACzCe,EAAmCnN,KAAnCmN,iBAAkBF,EAAiBjN,KAAjBiN,aAE1B,OAAO,IAAIU,SAAQ,SAACC,EAASC,GAC3B,IAAIC,EAAU1B,EAAQ0B,QAAU1B,EAAQ0B,QAAU,IAAIC,eAEtDD,EAAQE,KAAKN,EAAQpB,GAAK,GACtB,iBAAkBF,IACpB0B,EAAQG,aAAe7B,EAAQ6B,cAGV,WAAnB,EAAOf,IACT3B,OAAOC,KAAK0B,GAASnJ,SAAQ,SAAAmK,GAC3BJ,EAAQK,iBAAiBD,EAAKhB,EAAQgB,G,IAM1C,IAmE2BE,EAnErBC,EAAc,EAAKnB,QAgEzB,GA/DA3B,OAAOC,KAAK6C,GAAatK,SAAQ,SAAAmK,GAC/BJ,EAAQK,iBAAiBD,EAAKG,EAAYH,G,IAI5CJ,EAAQQ,YAAc,WACpBrC,EAAS,mBAAoBK,E,EAI/BwB,EAAQS,UAAY,WAClBtC,EAAS,kB,EAIX6B,EAAQU,mBAAqB,WAC3B,GAA2B,IAAvBV,EAAQW,WACV,GAAuB,MAAnBX,EAAQY,OAAgB,CAC1B,IAAMC,EAAcb,EAAQc,kBAAkB,gBAG1CD,IAAqD,IAAtCA,EAAYE,QAAQ,aACrCjB,EAAQ7D,EAAgB+D,EAAQ9D,WACE,gBAAzB8D,EAAQG,aACjBL,EAAQ,CAACE,EAAQ9D,WAEjB4D,EAAQE,EAAQ9D,S,MAEb,GAAuB,MAAnB8D,EAAQY,OACb,EAAKtB,SACP5G,QAAQC,KAAK,mCAAoCqH,GAEnDF,EAAQE,EAAQ9D,eACX,GAAuB,MAAnB8D,EAAQY,OACb,EAAKtB,SACP5G,QAAQC,KAAK,+BAAgCqH,GAE/CF,EAAQ,QACH,CACL,IAAMrB,EAAQ,IAAI1L,MAAM,kBACxB0L,EAAMuB,QAAUA,EAChBvB,EAAMvC,SAAW8D,EAAQ9D,SACzBuC,EAAMmC,OAASZ,EAAQY,OACnB,EAAKtB,UACP5G,QAAQ+F,MAAM,mBAAoBuB,GAClCtH,QAAQ+F,MAAMA,GACd/F,QAAQ+F,MAAMA,EAAMvC,WAGtBmD,EAAiBZ,GAEjBsB,EAAOtB,E,GAMT,qBAAsBH,GACgB,mBAA7BA,EAAQ0C,mBACjBhB,EAAQiB,WAAa3C,EAAQ0C,kBAI7B7B,GAnRV,SAA8BA,GAC5B,IAAM+B,EACJrL,MAAMqB,QAAQiI,IACdA,EAAahI,OACX,SAAAgK,GAAW,MACc,mBAAhBA,GAAqD,IAAvBA,EAAYxO,M,IAUvD,OAPKuO,GACHxI,QAAQC,KACN,kHAKGuI,C,CAoQiBE,CAAqBjC,GAAe,CACtD,IAAMkC,EAAkB5D,OAAO6D,OAAO,CAAC,EAAGlC,EAAS,EAAKA,SAClDmC,EAAW,CAAE3B,OAAAA,EAAQpB,IAAAA,EAAKY,QAASiC,GAGnCG,GAFmBlB,EAEanB,EAFA,SAAAsC,GAAI,OACxCnB,EAAUoB,QAAO,SAACC,EAAOC,GAAE,OAAKA,EAAGD,EAAOJ,E,GAAWE,E,GAEvDzB,EAAUwB,EAAaxB,E,CAIrB,oBAAqB1B,GACnBA,EAAQuD,kBACV7B,EAAQ6B,iBAAkB,GAI1B,SAAUvD,EACZ0B,EAAQ8B,KAAKxD,EAAQvC,MAErBiE,EAAQ8B,M,OAKd,8BAUStD,EAAKY,EAASe,EAAca,EAAkBa,GACrD,OAAO3P,KAAK6P,aAAavD,EAAK,MAAOY,EAAS,CAC5Ce,aAAAA,EACAa,iBAAAA,EACAa,gBAAAA,G,IAIJ,6CAUwBrD,GAAqD,IAAhDwD,EAAS,UAAH,6CAAG,CAAC,EAAGhB,EAAgB,uCAAEa,EAAe,uCACrEI,EAAqBzD,EAEH,WAAlB,EAAOwD,KACJxE,EAAcwE,KACjBC,GAAsB5D,EAAe6D,sBAAsBF,KAG/D,IAAM5C,EAAU,CAAE+C,OAAQvE,EAAWE,YAErC,OAAO5L,KAAKkQ,SACVH,EACA7C,EAHmB,OAKnB4B,EACAa,E,IAIJ,4CAUuBrD,GAAqD,IAAhDwD,EAAS,UAAH,6CAAG,CAAC,EAAGhB,EAAgB,uCAAEa,EAAe,uCACpEI,EAAqBzD,EAEH,WAAlB,EAAOwD,KACJxE,EAAcwE,KACjBC,GAAsB5D,EAAe6D,sBAAsBF,KAG/D,IAAM5C,EAAU,CAAE+C,OAAQvE,EAAWI,KAErC,OAAO9L,KAAKkQ,SACVH,EACA7C,EAHmB,OAKnB4B,EACAa,E,IAIJ,mCAYErD,EACA6D,GAIA,IAHAL,EAAS,UAAH,6CAAG,CAAC,EACVhB,EAAgB,uCAChBa,EAAe,uCAEXI,EAAqBzD,EAEH,WAAlB,EAAOwD,KACJxE,EAAcwE,KACjBC,GAAsB5D,EAAe6D,sBAAsBF,KAI/D,IAaM5C,EAAU,CAAE+C,OAJa9D,EAAeiE,6BAC5CD,EAV0B,CAC1B,SACA,UACA,aACA,YACA,YACA,eASF,OAAOnQ,KAAKkQ,SACVH,EACA7C,EAHmB,cAKnB4B,EACAa,E,IAIJ,kCAYErD,EACA6D,GAIA,IAHAL,EAAS,UAAH,6CAAG,CAAC,EACVhB,EAAgB,uCAChBa,EAAe,uCAEXI,EAAqBzD,EAEH,WAAlB,EAAOwD,KACJxE,EAAcwE,KACjBC,GAAsB5D,EAAe6D,sBAAsBF,KAI/D,IAaM5C,EAAU,CAAE+C,OAJa9D,EAAeiE,6BAC5CD,EAV0B,CAC1B,QACA,SACA,YACA,aACA,WACA,cASF,OAAOnQ,KAAKkQ,SACVH,EACA7C,EAHmB,cAKnB4B,EACAa,E,IAIJ,mCAYErD,EACA6D,GAIA,IAHAL,EAAS,UAAH,6CAAG,CAAC,EACVhB,EAAgB,uCAChBa,EAAe,uCAEXI,EAAqBzD,EAEH,WAAlB,EAAOwD,KACJxE,EAAcwE,KACjBC,GAAsB5D,EAAe6D,sBAAsBF,KAI/D,IAYM5C,EAAU,CAAE+C,OAJa9D,EAAeiE,6BAC5CD,EAT0B,CAC1B,SACA,UACA,aACA,YACA,gBASF,OAAOnQ,KAAKkQ,SACVH,EACA7C,EAHmB,cAKnB4B,EACAa,E,IAIJ,6BA0BA,eAcErD,EACA6D,EACAE,EACAP,GAIA,IAEIQ,EAJJxB,EAAgB,uCAChBa,EAAe,uCAETzC,EAAU,CAAC,EAkCjB,OAtCW,UAAH,8CAONoD,EAAsB,CACpB,aACA,YACA,YACA,cAGFA,EAAsB,CACpB,sBAAuB,CAAC,qBACxB,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAAe,aAC1C,yBAA0B,CAAC,cAAe,aAC1C,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,cAGzBD,IACFnD,EAAQqD,MAAQpE,EAAeqE,4BAA4BH,KAI/DnD,EAAQ+C,OAAS9D,EAAesE,sCAC9BN,EACAG,GAGKtQ,KAAKkQ,SAAS5D,EAAKY,EAAS,cAAe4B,EAAkBa,E,IAGtE,4CAcErD,EACA6D,EACAE,EACAP,GAIA,IAEIQ,EAJJxB,EAAgB,uCAChBa,EAAe,uCAETzC,EAAU,CAAC,EA+BjB,OAnCW,UAAH,8CAONoD,EAAsB,CACpB,SACA,UACA,cACA,YACA,eAGFA,EAAsB,CACpB,0BAA2B,CAAC,eAC5B,0BAA2B,CAAC,eAC5B,0BAA2B,CAAC,aAC5B,0BAA2B,CAAC,aAC5B,0BAA2B,CAAC,aAC5B,0BAA2B,CAAC,aAC5B,0BAA2B,CAAC,cAG1BD,IACFnD,EAAQqD,MAAQpE,EAAeqE,4BAA4BH,KAI/DnD,EAAQ+C,OAAS9D,EAAesE,sCAC9BN,EACAG,GAGKtQ,KAAKkQ,SAAS5D,EAAKY,EAAS,cAAe4B,EAAkBa,E,IAGtE,uDAaErD,EACA6D,EACAL,EACAhB,EACAa,GAEA,IAAMzC,EAAU,CAAC,EACXwD,EAAmB,oBACnBJ,EAAsB,CAC1B,sBAAuB,CAACI,GACxB,sBAAuB,CAACA,GACxB,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,IAG1BC,EAAuBR,EAU3B,OATKA,IACHQ,EAAuB,CAAC,CAAEC,UAAWF,KAGvCxD,EAAQ+C,OAAS9D,EAAesE,sCAC9BE,EACAL,GAGKtQ,KAAKkQ,SAAS5D,EAAKY,EAAS,cAAe4B,EAAkBa,E,IAGtE,6DAeErD,EACA6D,EACAE,EACAP,EACAhB,EACAa,GAEA,IAAMzC,EAAU,CAAC,EAEXoD,EAAsB,CAC1B,sBAAuB,EAAI/E,OAAOsF,OAAOnF,KAGvCiF,EAAuBR,EAc3B,OAbKA,IACHQ,EAAuB,CAAC,CAAEC,UAPH,8BAUrBP,IACFnD,EAAQqD,MAAQpE,EAAeqE,4BAA4BH,IAG7DnD,EAAQ+C,OAAS9D,EAAesE,sCAC9BE,EACAL,GAGKtQ,KAAKkQ,SAAS5D,EAAKY,EAAS,cAAe4B,EAAkBa,E,IAGtE,+BAYUrD,EAAKY,EAASrD,EAAMiF,EAAkBa,EAAiB7B,GAC/D,OAAO9N,KAAK6P,aAAavD,EAAK,OAAQY,EAAS,CAC7CrD,KAAAA,EACAiF,iBAAAA,EACAa,gBAAAA,EACA7B,QAAAA,G,IAIJ,8CAUyBxB,EAAKzC,EAAMiF,EAAkBa,GACpD,IAAMzC,EAAU,CAAE,eAAgBxB,EAAWE,YAC7C,OAAO5L,KAAK8Q,UACVxE,EACAY,EACArD,EACAiF,EACAa,E,IAIJ,uBAsNA,iBAO+B,IAAdvD,EAAU,UAAH,6CAAG,CAAC,EAC1BH,EAAS,sBACT,IAAI0D,GAAkB,EAClBrD,EAAM,GAAH,OAAMtM,KAAK2M,QAAO,YASzB,MARI,gBAAiBP,IACnBE,GAAOH,EAAe6D,sBAAsB5D,EAAQ2E,cAElD,oBAAqB3E,GACnBA,EAAQuD,kBACVA,EAAkBvD,EAAQuD,iBAGvB3P,KAAKgR,wBAAwB1E,EAAK,CAAC,GAAG,EAAOqD,E,IAGtD,2CAQsBvD,GACpB,KAAM,qBAAsBA,GAC1B,MAAM,IAAIvL,MACR,kEAGJoL,EAAS,8BAAD,OAA+BG,EAAQ6E,mBAC/C,IAAM3E,EAAM,GAAH,OAAMtM,KAAK6M,QAAO,oBAAYT,EAAQ6E,iBAAgB,aAC3DtB,GAAkB,EAMtB,MALI,oBAAqBvD,GACnBA,EAAQuD,kBACVA,EAAkBvD,EAAQuD,iBAGvB3P,KAAKgR,wBAAwB1E,EAAK,CAAC,GAAG,EAAOqD,E,IAGtD,uCAQ8B,IAAdvD,EAAU,UAAH,6CAAG,CAAC,EACrBE,EAAMtM,KAAK2M,QACX,qBAAsBP,IACxBH,EAAS,0BAAD,OAA2BG,EAAQ6E,mBAC3C3E,GAAO,YAAJ,OAAgBF,EAAQ6E,mBAE7B3E,GAAO,UACH,gBAAiBF,IACnBE,GAAOH,EAAe6D,sBAAsB5D,EAAQ2E,cAEtD,IAAIpB,GAAkB,EAMtB,MALI,oBAAqBvD,GACnBA,EAAQuD,kBACVA,EAAkBvD,EAAQuD,iBAGvB3P,KAAKgR,wBAAwB1E,EAAK,CAAC,GAAG,EAAOqD,E,IAGtD,4CASuBvD,GACrB,KAAM,qBAAsBA,GAC1B,MAAM,IAAIvL,MACR,mEAGJ,KAAM,sBAAuBuL,GAC3B,MAAM,IAAIvL,MACR,oEAIJoL,EAAS,+BAAD,OAAgCG,EAAQ8E,oBAChD,IAAM5E,EAAM,GAAH,OAAMtM,KAAK6M,QAAO,oBAAYT,EAAQ6E,iBAAgB,mBAAW7E,EAAQ8E,kBAAiB,aAC/FvB,GAAkB,EAMtB,MALI,oBAAqBvD,GACnBA,EAAQuD,kBACVA,EAAkBvD,EAAQuD,iBAGvB3P,KAAKgR,wBAAwB1E,EAAK,CAAC,GAAG,EAAOqD,E,IAGtD,0CASiC,IAAdvD,EAAU,UAAH,6CAAG,CAAC,EACxBE,EAAMtM,KAAK2M,QACXgD,GAAkB,EAyBtB,MAxBI,qBAAsBvD,GACxBE,GAAO,YAAJ,OAAgBF,EAAQ6E,kBACvB,sBAAuB7E,GACzBH,EAAS,kCAAD,OAC4BG,EAAQ8E,oBAE5C5E,GAAO,WAAJ,OAAeF,EAAQ8E,oBAE1BjF,EAAS,iCAAD,OAC2BG,EAAQ6E,oBAI7ChF,EAAS,wBAEXK,GAAO,aACH,gBAAiBF,IACnBE,GAAOH,EAAe6D,sBAAsB5D,EAAQ2E,cAElD,oBAAqB3E,GACnBA,EAAQuD,kBACVA,EAAkBvD,EAAQuD,iBAGvB3P,KAAKgR,wBAAwB1E,EAAK,CAAC,GAAG,EAAOqD,E,IAGtD,6CAQwBvD,GACtB,KAAM,qBAAsBA,GAC1B,MAAM,IAAIvL,MAAM,mCAElB,KAAM,sBAAuBuL,GAC3B,MAAM,IAAIvL,MAAM,oCAElB,KAAM,mBAAoBuL,GACxB,MAAM,IAAIvL,MAAM,iCAGlB,IAAM8N,EAAcvC,EAAQuC,aAAejD,EAAWC,MAChDwF,EAAiB/E,EAAQ+E,gBAAkB,IAC3CrB,EAAS,GAEfA,EAAO3E,KAAK,oBACZ2E,EAAO3E,KAAK,YAAD,OAAaiB,EAAQ6E,mBAChCnB,EAAO3E,KAAK,aAAD,OAAciB,EAAQ8E,oBACjCpB,EAAO3E,KAAK,aAAD,OAAciB,EAAQgF,iBACjCtB,EAAO3E,KAAK,eAAD,OAAgBwD,IAC3BmB,EAAO3E,KAAK,kBAAD,OAAmBgG,IAE9B,IAAME,EAAcvB,EAAOwB,KAAK,KAEhC,MAAO,GAAP,OAAUtR,KAAK6M,QAAO,YAAIwE,E,IAG5B,8CASyBjF,GACvB,KAAM,qBAAsBA,GAC1B,MAAM,IAAIvL,MACR,qEAGJ,KAAM,sBAAuBuL,GAC3B,MAAM,IAAIvL,MACR,sEAGJ,KAAM,mBAAoBuL,GACxB,MAAM,IAAIvL,MACR,mEAGJoL,EAAS,iCAAD,OAAkCG,EAAQgF,iBAClD,IAAM9E,EAAM,GAAH,OAAMtM,KAAK6M,QAAO,oBAAYT,EAAQ6E,iBAAgB,mBAAW7E,EAAQ8E,kBAAiB,sBAAc9E,EAAQgF,eAAc,aACnIzB,GAAkB,EAMtB,MALI,oBAAqBvD,GACnBA,EAAQuD,kBACVA,EAAkBvD,EAAQuD,iBAGvB3P,KAAKgR,wBAAwB1E,EAAK,CAAC,GAAG,EAAOqD,E,IAGtD,4CASuBvD,GACrB,KAAM,qBAAsBA,GAC1B,MAAM,IAAIvL,MACR,mEAGJ,KAAM,sBAAuBuL,GAC3B,MAAM,IAAIvL,MACR,oEAGJ,KAAM,mBAAoBuL,GACxB,MAAM,IAAIvL,MACR,iEAGJ,KAAM,iBAAkBuL,GACtB,MAAM,IAAIvL,MACR,+DAGJoL,EAAS,mBAAD,OACaG,EAAQmF,aAAa1I,WAAU,wBAChDuD,EAAQgF,iBAGZ,IAAM9E,EAAM,GAAH,OAAMtM,KAAK6M,QAAO,oBAAYT,EAAQ6E,iBAAgB,mBAC7D7E,EAAQ8E,kBAAiB,sBAEzB9E,EAAQgF,eAAc,mBACbhF,EAAQmF,aAAa1I,YAExBsH,EAAe/D,EAAf+D,WACJR,GAAkB,EAClB,oBAAqBvD,GACnBA,EAAQuD,kBACVA,EAAkBvD,EAAQuD,iBAI9B,IAAIb,GAAmB,EAKvB,GAJI,qBAAsB1C,IACxB0C,EAAmB1C,EAAQ0C,mBAGxBqB,EACH,OAAOnQ,KAAKwR,wCACVlF,GACA,GACA,GACA,EACAwC,EACAa,GAKJ,GADyBxD,EAAesF,qBAAqBtB,GACxC1P,OAAS,EAAG,CAM/B,IAiBMyM,EAAU,CACd+C,OAAQ9D,EAAesE,sCACrBN,EAnBwB,CAC1B,sBAAuB,CAAC,4BACxB,sBAAuB,CAAC,qBACxB,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAAe,aAC1C,yBAA0B,CAAC,cAAe,aAC1C,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,aAC3B,0BAA2B,CAAC,aAC5B,0BAA2B,CAAC,gBAS9B,OAAOnQ,KAAKkQ,SAAS5D,EAAKY,EAAS,cAAe4B,EAAkBa,E,CAGtE,IAAM+B,EAAkBvF,EAAewF,oBAAoBxB,GAE3D,GAAIuB,EAAgBE,WAAW,eAC7B,OAAO5R,KAAKwR,wCACVlF,EACA6D,GACA,GACA,EACArB,EACAa,GAGJ,GAAI+B,EAAgBE,WAAW,SAC7B,OAAO5R,KAAK6R,uBACVvF,EACA6D,GACA,GACA,GACA,EACArB,EACAa,GAGJ,GAAI+B,EAAgBE,WAAW,SAC7B,OAAO5R,KAAK8R,uBACVxF,EACA6D,GACA,GACA,GACA,EACArB,EACAa,GAIJ,MAAM,IAAI9O,MAAM,cAAD,OACC6Q,EAAe,8C,IAUjC,8CAWyBtF,GACvB,KAAM,qBAAsBA,GAC1B,MAAM,IAAIvL,MACR,qEAGJ,KAAM,sBAAuBuL,GAC3B,MAAM,IAAIvL,MACR,sEAGJ,KAAM,mBAAoBuL,GACxB,MAAM,IAAIvL,MACR,mEAIJ,IAAIyL,EAAM,GAAH,OAAMtM,KAAK6M,QAAO,oBAAYT,EAAQ6E,iBAAgB,mBAAW7E,EAAQ8E,kBAAiB,sBAAc9E,EAAQgF,eAAc,aAE7HjB,EAA4B/D,EAA5B+D,WAAYY,EAAgB3E,EAAhB2E,YAEhBpB,GAAkB,EAClB,oBAAqBvD,GACnBA,EAAQuD,kBACVA,EAAkBvD,EAAQuD,iBAI9B,IAAIb,GAAmB,EAKvB,GAJI,qBAAsB1C,IACxB0C,EAAmB1C,EAAQ0C,mBAGxBqB,EAKH,OAHIY,IACFzE,GAAOH,EAAe6D,sBAAsBe,IAEvC/Q,KAAKkQ,SACV5D,EAnBY,CAAC,EAcM,cAQnBwC,EACAa,GAIJ,IAAM+B,EAAkBvF,EAAewF,oBAAoBxB,GAC3D,GAAIuB,EAAgBE,WAAW,SAC7B,OAAO5R,KAAK+R,cACVzF,EACA6D,EACAY,EACAjC,EACAa,GAGJ,GAAI+B,EAAgBE,WAAW,SAC7B,OAAO5R,KAAKgS,cACV1F,EACA6D,EACAY,EACAjC,EACAa,GAGJ,GAAI+B,EAAgBE,WAAW,QAC7B,OAAO5R,KAAKiS,aACV3F,EACA6D,EACAY,EACAjC,EACAa,GAGJ,GAAI+B,IAAoBhG,EAAWI,IACjC,OAAO9L,KAAKkS,uBACV5F,EACAyE,EACAjC,EACAa,GAIJ,MAAM,IAAI9O,MACR,qBAAc6Q,EAAe,sBAC3B,sC,IAIN,+CAW0BtF,GACxB,KAAM,qBAAsBA,GAC1B,MAAM,IAAIvL,MACR,qEAGJ,KAAM,sBAAuBuL,GAC3B,MAAM,IAAIvL,MACR,sEAGJ,KAAM,mBAAoBuL,GACxB,MAAM,IAAIvL,MACR,mEAIJ,IAAIyL,EAAM,GAAH,OAAMtM,KAAK6M,QAAO,oBAAYT,EAAQ6E,iBAAgB,mBAAW7E,EAAQ8E,kBAAiB,sBAAc9E,EAAQgF,eAAc,cAE7HjB,EAA4B/D,EAA5B+D,WAAYY,EAAgB3E,EAAhB2E,YAEhBpB,GAAkB,EAClB,oBAAqBvD,GACnBA,EAAQuD,kBACVA,EAAkBvD,EAAQuD,iBAI9B,IAAIb,GAAmB,EAKvB,GAJI,qBAAsB1C,IACxB0C,EAAmB1C,EAAQ0C,mBAGxBqB,EAKH,OAHIY,IACFzE,GAAOH,EAAe6D,sBAAsBe,IAEvC/Q,KAAKkQ,SACV5D,EAnBY,CAAC,EAcM,cAQnBwC,EACAa,GAIJ,IAAM+B,EAAkBvF,EAAewF,oBAAoBxB,GAC3D,GAAIuB,EAAgBE,WAAW,SAC7B,OAAO5R,KAAK+R,cACVzF,EACA6D,EACAY,EACAjC,EACAa,GAIJ,MAAM,IAAI9O,MACR,qBAAc6Q,EAAe,sBAC3B,sC,IAIN,oDAY+BtF,GAC7B,KAAM,qBAAsBA,GAC1B,MAAM,IAAIvL,MACR,4EAGJ,KAAM,sBAAuBuL,GAC3B,MAAM,IAAIvL,MACR,6EAGJ,KAAM,mBAAoBuL,GACxB,MAAM,IAAIvL,MACR,0EAGJ,KAAM,iBAAkBuL,GACtB,MAAM,IAAIvL,MACR,wEAIJoL,EAAS,4BAAD,OACsBG,EAAQmF,aAAa1I,WAAU,wBACzDuD,EAAQgF,iBAGZ,IAAI9E,EAAM,GAAH,OAAMtM,KAAK6M,QAAO,oBAAYT,EAAQ6E,iBAAgB,mBAC3D7E,EAAQ8E,kBAAiB,sBAEzB9E,EAAQgF,eAAc,mBACbhF,EAAQmF,aAAa1I,WAAU,aAElCsH,EAA4B/D,EAA5B+D,WAAYY,EAAgB3E,EAAhB2E,YAEhBpB,GAAkB,EAClB,oBAAqBvD,GACnBA,EAAQuD,kBACVA,EAAkBvD,EAAQuD,iBAG9B,IAAIb,GAAmB,EAKvB,GAJI,qBAAsB1C,IACxB0C,EAAmB1C,EAAQ0C,mBAGxBqB,EAKH,OAHIY,IACFzE,GAAOH,EAAe6D,sBAAsBe,IAEvC/Q,KAAKkQ,SAAS5D,EAjBP,CAAC,EAaM,eAI4B,EAAOqD,GAG1D,IAAM+B,EAAkBvF,EAAewF,oBAAoBxB,GAC3D,GAAIuB,EAAgBE,WAAW,SAC7B,OAAO5R,KAAK+R,cACVzF,EACA6D,EACAY,EACAjC,EACAa,GAGJ,GAAI+B,EAAgBE,WAAW,SAC7B,OAAO5R,KAAKgS,cACV1F,EACA6D,EACAY,EACAjC,EACAa,GAIJ,MAAM,IAAI9O,MACR,qBAAc6Q,EAAe,sBAC3B,mC,IAIN,qDAWgCtF,GAC9B,KAAM,qBAAsBA,GAC1B,MAAM,IAAIvL,MACR,4EAGJ,KAAM,sBAAuBuL,GAC3B,MAAM,IAAIvL,MACR,6EAGJ,KAAM,mBAAoBuL,GACxB,MAAM,IAAIvL,MACR,0EAGJ,KAAM,iBAAkBuL,GACtB,MAAM,IAAIvL,MACR,wEAIJ2F,QAAQ8G,MAAM,4BAAD,OACiBlB,EAAQmF,aAAa1I,WAAU,wBACzDuD,EAAQgF,iBAGZ,IAAI9E,EAAM,GAAH,OAAMtM,KAAK6M,QAAO,oBAAYT,EAAQ6E,iBAAgB,mBAC3D7E,EAAQ8E,kBAAiB,sBAEzB9E,EAAQgF,eAAc,mBACbhF,EAAQmF,aAAa1I,WAAU,cAElCsH,EAA4B/D,EAA5B+D,WAAYY,EAAgB3E,EAAhB2E,YAEhBpB,GAAkB,EAClB,oBAAqBvD,GACnBA,EAAQuD,kBACVA,EAAkBvD,EAAQuD,iBAI9B,IAAIb,GAAmB,EAKvB,GAJI,qBAAsB1C,IACxB0C,EAAmB1C,EAAQ0C,mBAGxBqB,EAKH,OAHIY,IACFzE,GAAOH,EAAe6D,sBAAsBe,IAEvC/Q,KAAKkQ,SACV5D,EAnBY,CAAC,EAcM,cAQnBwC,EACAa,GAIJ,IAAM+B,EAAkBvF,EAAewF,oBAAoBxB,GAC3D,GAAIuB,EAAgBE,WAAW,SAC7B,OAAO5R,KAAK+R,cACVzF,EACA6D,EACAY,EACAjC,EACAa,GAIJ,MAAM,IAAI9O,MACR,qBAAc6Q,EAAe,sBAC3B,mC,IAIN,sCASiBtF,GACf,KAAM,qBAAsBA,GAC1B,MAAM,IAAIvL,MAAM,kCAElB,KAAM,sBAAuBuL,GAC3B,MAAM,IAAIvL,MAAM,mCAElB,KAAM,mBAAoBuL,GACxB,MAAM,IAAIvL,MAAM,gCAElB,IAAMyL,EAAM,GAAH,OAAMtM,KAAK6M,QAAO,oBAAYT,EAAQ6E,iBAAgB,mBAAW7E,EAAQ8E,kBAAiB,sBAAc9E,EAAQgF,gBAEjHjB,EAAe/D,EAAf+D,WAAU,EACkB/D,EAA5BuD,gBAAAA,OAAe,IAAG,GAAK,IACMvD,EAA7B0C,iBAAAA,OAAgB,IAAG,GAAK,EAEhC,IAAKqB,EACH,OAAOnQ,KAAKmS,kCACV7F,GACA,GACA,EACAwC,EACAa,GACAyC,KAAK3G,GAGT,IAAMiG,EAAkBvF,EAAewF,oBAAoBxB,GAC3D,GAAIuB,IAAoBhG,EAAWC,MACjC,OAAO3L,KAAKmS,kCACV7F,EACA6D,GACA,EACArB,EACAa,GACAyC,KAAK3G,GAGT,MAAM,IAAI5K,MAAM,cAAD,OACC6Q,EAAe,gD,IAIjC,oCASetF,GACb,KAAM,qBAAsBA,GAC1B,MAAM,IAAIvL,MAAM,kCAElB,KAAM,sBAAuBuL,GAC3B,MAAM,IAAIvL,MAAM,mCAGlB,IAAMyL,EAAM,GAAH,OAAMtM,KAAK6M,QAAO,oBAAYT,EAAQ6E,iBAAgB,mBAAW7E,EAAQ8E,mBAE1Ef,EAAe/D,EAAf+D,WACJR,GAAkB,EAClB,oBAAqBvD,GACnBA,EAAQuD,kBACVA,EAAkBvD,EAAQuD,iBAI9B,IAAIb,GAAmB,EAKvB,GAJI,qBAAsB1C,IACxB0C,EAAmB1C,EAAQ0C,mBAGxBqB,EACH,OAAOnQ,KAAKmS,kCACV7F,GACA,GACA,EACAwC,EACAa,GAIJ,IAAM+B,EAAkBvF,EAAewF,oBAAoBxB,GAC3D,GAAIuB,IAAoBhG,EAAWC,MACjC,OAAO3L,KAAKmS,kCACV7F,EACA6D,GACA,EACArB,EACAa,GAIJ,MAAM,IAAI9O,MAAM,cAAD,OACC6Q,EAAe,8C,IAIjC,mCAOctF,GACZ,KAAM,qBAAsBA,GAC1B,MAAM,IAAIvL,MAAM,kCAGlB,IAAMyL,EAAM,GAAH,OAAMtM,KAAK6M,QAAO,oBAAYT,EAAQ6E,kBAEvCd,EAAe/D,EAAf+D,WAAU,EACkB/D,EAA5BuD,gBAAAA,OAAe,IAAG,GAAK,IACMvD,EAA7B0C,iBAAAA,OAAgB,IAAG,GAAK,EAEhC,IAAKqB,EACH,OAAOnQ,KAAKmS,kCACV7F,GACA,GACA,EACAwC,EACAa,GAIJ,IAAM+B,EAAkBvF,EAAewF,oBAAoBxB,GAC3D,GAAIuB,IAAoBhG,EAAWC,MACjC,OAAO3L,KAAKmS,kCACV7F,EACA6D,GACA,EACArB,EACAa,GAIJ,MAAM,IAAI9O,MAAM,cAAD,OACC6Q,EAAe,6C,IAIjC,sCAaiBtF,GACf,KAAM,gBAAiBA,GACrB,MAAM,IAAIvL,MAAM,4BAGlB,IAAMyL,EAAMF,EAAQiG,YACZlC,EAA0B/D,EAA1B+D,WAAYE,EAAcjE,EAAdiE,UAAS,EACOjE,EAA5BuD,gBAAAA,OAAe,IAAG,GAAK,IACMvD,EAA7B0C,iBAAAA,OAAgB,IAAG,GAAK,EAEhC,IAA6C,IAAzC9O,KAAKgN,WAAW6B,QAAQ,YAC1B,OAAO7O,KAAKkQ,SAAS5D,EAAKF,EAAQc,QAAS,cAAe,KAAMyC,GAGlE,GAAIQ,EACF,IAGE,GAAsB,WAFEhE,EAAewF,oBAAoBxB,GAGzD,OAAOnQ,KAAK6R,uBACVvF,EACA6D,EACAE,GACA,GACA,EACAvB,EACAa,E,CAGJ,MAAM2C,G,CAMV,OAAOtS,KAAKwR,wCACVlF,EACA6D,EACAE,GACA,EACAvB,EACAa,E,IAIJ,oCASevD,GACb,KAAM,aAAcA,GAClB,MAAM,IAAIvL,MAAM,qCAGlB,IAAIyL,EAAM,GAAH,OAAMtM,KAAK+M,QAAO,YACrB,qBAAsBX,IACxBE,GAAO,IAAJ,OAAQF,EAAQ6E,mBACpB,MAE0B1I,EAAgB6D,EAAQ5D,UAA3CqB,EAAI,EAAJA,KAAMpB,EAAQ,EAARA,SACRyE,EAAU,CACd,eAAgB,0DAAF,OAA4DzE,EAAQ,MAClF,EACkC2D,EAA5BuD,gBAAAA,OAAe,IAAG,GAAK,EAC/B,OAAO3P,KAAK8Q,UACVxE,EACAY,EACArD,EACAuC,EAAQ0C,iBACRa,EACAvD,EAAQ0B,Q,QAEX,6CArxDyC,IAAbgC,EAAS,UAAH,6CAAG,CAAC,EACjCyC,EAAc,IAOlB,OANAhH,OAAOC,KAAKsE,GAAQ/L,SAAQ,SAACmK,EAAKvJ,GAClB,IAAVA,IACF4N,GAAe,KAEjBA,GAAe,GAAJ,OAAOrE,EAAG,YAAIsE,mBAAmB1C,EAAO5B,I,IAE9CqE,C,IACR,6CA+V8B3B,GAC7B,IAAKA,EACH,MAAM,IAAI/P,MAAM,2BAAD,OAA4B+P,IAG7C,IAAM6B,EAAW7B,EAAU/B,QAAQ,KACnC,IAAkB,IAAd4D,EACF,MAAM,IAAI5R,MAAM,2BAAD,OAA4B+P,IAG7C,IAAM8B,EAAgB9B,EAAU1F,MAAM,EAAGuH,GAEzC,IADc,CAAC,cAAe,QAAS,OAAQ,SACpC/M,SAASgN,GAClB,MAAM,IAAI7R,MAAM,2BAAD,OAA4B+P,IAG7C,GAAIA,EAAU1F,MAAMuH,EAAW,GAAG/M,SAAS,KACzC,MAAM,IAAI7E,MAAM,2BAAD,OAA4B+P,G,IAE9C,qCA2QsBA,GAGrB,OAFAzE,EAAewG,wBAAwB/B,GAEhCA,EAAUjG,MAAM,I,IAGzB,kDAQoCwF,EAAYG,GAC9C,IAAK3M,MAAMqB,QAAQmL,GACjB,MAAM,IAAItP,MAAM,uDAgBlB,OAbwBsP,EAAW1L,KAAI,SAAAmO,GAAQ,IACrChC,EAAcgC,EAAdhC,UAGR,GADAzE,EAAewG,wBAAwB/B,IAClCN,EAAoB5K,SAASkL,GAChC,MAAM,IAAI/P,MAAM,cAAD,OACC+P,EAAS,6CAI3B,OAAOA,C,IAGcU,KAAK,K,IAG9B,2DAYEnB,EACAG,GACA,WACA,IAAK3M,MAAMqB,QAAQmL,GACjB,MAAM,IAAItP,MAAM,uDAGlB,IAAK8C,MAAMqB,QAAQsL,KAAyBlF,EAASkF,GACnD,MAAM,IAAIzP,MACR,mEAIJ,IAAMgS,EAAkB,GAwExB,GAtEA1C,EAAWpM,SAAQ,SAAA6O,GAAQ,IACjBE,EAAiCF,EAAjCE,kBAAmBlC,EAAcgC,EAAdhC,UAC3BzE,EAAewG,wBAAwB/B,GACvC,IAAImC,EAAa,4BAAH,OAA+BnC,EAAS,KAEtD,GAAIxF,EAASkF,GAAsB,CAGjC,KACG/E,OAAOsF,OAAOP,GACZ0C,KAAK,GACLtN,SAASkL,IAEPA,EAAUqC,SAAS,OAAUrC,EAAUqC,SAAS,MAInD,YAHAhH,EAAS,cAAD,OACQ2E,EAAS,6CAM7B,GAAIkC,EAAmB,CACrB,GAA0B,MAAtBA,EAA2B,CAC7B,IAAKvH,OAAOC,KAAK8E,GAAqB5K,SAASoN,GAC7C,MAAM,IAAIjS,MAAM,mBAAD,OACMiS,EAAiB,6CAIxC,IAAMI,EAAqB5C,EAAoBwC,GAE/C,IAAKI,EAAmBxN,SAASkL,GAAY,CAC3C,IAAMuC,EAAahH,EAAeiH,gBAAgBxC,GAAW,GAC7DsC,EAAmBzO,KAAI,SAAA4O,GACrB,IAAMC,EAAenH,EAAeiH,gBAClCC,GACA,GAGF,GAFqBF,IAAeG,IAIjC1C,EAAUqC,SAAS,QAASrC,EAAUqC,SAAS,KAKlD,MAAM,IAAIpS,MAAM,mBAAD,OACMiS,EAAiB,4C,KAM5CC,GAAc,qBAAJ,OAAyBD,E,OAEhC,GACLnP,MAAMqB,QAAQsL,KACbA,EAAoB5K,SAASkL,GAO9B,YALI,EAAKxD,SACP5G,QAAQC,KAAK,cAAD,OACImK,EAAS,8CAM7BiC,EAAgB1H,KAAK4H,E,KAGlBF,EAAgBpS,OACnB,MAAM,IAAII,MAAM,yCAAD,OAA0CsF,KAAKC,UAAU+J,KAG1E,OAAO0C,EAAgBvB,KAAK,K,IAG9B,mDAOmD,IAAhBjB,EAAY,UAAH,6CAAG,GAC7C,OAAyB,IAArBA,EAAU5P,OACL,SAAP,OAAgB4P,EAAU,GAAE,KAEL,IAArBA,EAAU5P,OACL,SAAP,OAAgB4P,EAAU,GAAE,YAAIA,EAAU,IAGrC,U,IAGT,0CAQ4BF,GAC1B,IAAMoD,EAAQ,IAAIC,IAElB,OAAKrD,GAAeA,EAAW1P,QAI/B0P,EAAWpM,SAAQ,SAAA6O,GAAQ,IACjBhC,EAAcgC,EAAdhC,UACF6C,EAAOtH,EAAeiH,gBAAgBxC,GAAW,GACvD2C,EAAMG,IAAI,GAAD,OAAID,EAAI,K,IAGZ9P,MAAMgQ,KAAKJ,IATTA,C,IAYX,yCAW2BpD,GACzB,IAAKA,IAAeA,EAAW1P,OAC7B,MAAM,IAAII,MAAM,sCAGlB,IAAM+S,EAAmBzH,EAAesF,qBAAqBtB,GAC7D,GAAgC,IAA5ByD,EAAiBnT,OACnB,MAAM,IAAII,MAAM,wDACX,GAAI+S,EAAiBnT,OAAS,EACnC,MAAM,IAAII,MAAM,mDAGlB,OAAO+S,EAAiB,E,qFACzB,C,CAz8BiB,G,+FGrDdC,G,QAFmB,iBAAhBC,aAAuD,mBAApBA,YAAYD,IAGpD,kBAAMC,YAAYD,KAAlB,EACA,kBAAM9S,KAAK8S,KAAX,GAMG,SAASE,EAAcC,GAC5BC,qBAAqBD,EAAUE,GAChC,CAEM,SAASC,EAAeC,EAAoBC,GACjD,IAAMC,EAAQT,IAUd,IAAMG,EAAuB,CAC3BE,GAAIK,uBATN,SAASC,IACHX,IAAQS,GAASD,EACnBD,EAASK,KAAK,MAEdT,EAAUE,GAAKK,sBAAsBC,EAExC,KAMD,OAAOR,CACR,CClCD,IAAIU,GAAgB,EAGpB,SAAgBC,EAAiBC,GAC/B,QADsE,IAAvCA,IAAAA,GAAwB,IACzC,IAAVF,GAAeE,EAAa,CAC9B,IAAMC,EAAMC,SAASC,cAAc,OAC7BC,EAAQH,EAAIG,MAClBA,EAAMC,MAAQ,OACdD,EAAME,OAAS,OACfF,EAAMG,SAAW,SAEfL,SAASM,KAA6BC,YAAYR,GAEpDH,EAAOG,EAAIS,YAAcT,EAAIU,YAE3BT,SAASM,KAA6BI,YAAYX,EACrD,CAED,OAAOH,CACR,CAOD,IAAIe,EAAwC,KAQ5C,SAAgBC,EAAiBd,GAC/B,QAD6E,IAA9CA,IAAAA,GAAwB,GAC/B,OAApBa,GAA4Bb,EAAa,CAC3C,IAAMe,EAAWb,SAASC,cAAc,OAClCa,EAAaD,EAASX,MAC5BY,EAAWX,MAAQ,OACnBW,EAAWV,OAAS,OACpBU,EAAWT,SAAW,SACtBS,EAAWC,UAAY,MAEvB,IAAMC,EAAWhB,SAASC,cAAc,OAClCgB,EAAaD,EAASd,MAqB5B,OApBAe,EAAWd,MAAQ,QACnBc,EAAWb,OAAS,QAEpBS,EAASN,YAAYS,GAEnBhB,SAASM,KAA6BC,YAAYM,GAEhDA,EAASK,WAAa,EACxBP,EAAkB,uBAElBE,EAASK,WAAa,EAEpBP,EAD0B,IAAxBE,EAASK,WACO,WAEA,sBAIpBlB,SAASM,KAA6BI,YAAYG,GAE7CF,CACR,CAED,OAAOA,CACR,CCuvBD,IClsBMQ,EAAiB,SAACtR,EAAekF,GAAhB,OAA8BlF,CAA9B,EAavB,SAAwBuR,EAAT,GAoBX,MAnBFC,EAmBE,EAnBFA,cACAC,EAkBE,EAlBFA,sBACAC,EAiBE,EAjBFA,YACAC,EAgBE,EAhBFA,8BACAC,EAeE,EAfFA,uBACAC,EAcE,EAdFA,0BACAC,EAaE,EAbFA,kBACAC,EAYE,EAZFA,sCACAC,EAWE,EAXFA,cAYA,qBA2BE,WAAYlH,GAAiB,aAC3B,cAAMA,IAAN,MA3BFmH,eAAsBH,EAAkB,EAAKhH,OAAN,WA0BV,EAzB7BoH,eAyB6B,IAxB7BC,2BAA+C,KAwBlB,EAd7BC,MAAe,CACb/S,UAAU,UACVgT,aAAa,EACbC,gBAAiB,UACjBC,aAC4C,iBAAnC,EAAKzH,MAAM0H,oBACd,EAAK1H,MAAM0H,oBACX,EACNC,0BAA0B,GAMC,EA8M7BC,0BA9M6B,IAoN7BA,sBAAuBC,EAAAA,EAAAA,IACrB,SACEC,EACAC,EACAC,EACAC,GAJF,OAMI,EAAKjI,MAAMkI,gBAAgD,CAC3DJ,mBAAAA,EACAC,kBAAAA,EACAC,kBAAAA,EACAC,iBAAAA,GAVJ,IArN2B,EAmO7BE,mBAnO6B,IAwO7BA,eAAgBN,EAAAA,EAAAA,IACd,SACEL,EACAC,EACAE,GAHF,OAKI,EAAK3H,MAAMoI,SAAkC,CAC7CZ,gBAAAA,EACAC,aAAAA,EACAE,yBAAAA,GARJ,IAzO2B,EA0R7BU,mBA1R6B,IA2R7BA,cAAgB,SAACnT,GACf,IAQIqQ,EARJ,EAAwC,EAAKvF,MAArCoG,EAAR,EAAQA,UAAWkC,EAAnB,EAAmBA,SAAUC,EAA7B,EAA6BA,OAEvBC,EAAiB,EAAKC,mBAC1BxB,GAAyCqB,EACzCrB,GAAyCsB,EACzCtB,GAAyCb,GAI3C,GAAIoC,EAAeE,eAAexT,GAChCqQ,EAAQiD,EAAetT,OAClB,CACL,IAAMuD,EAASiO,EAAc,EAAK1G,MAAO9K,EAAO,EAAKiS,gBAC/ClC,EAAO2B,EAAY,EAAK5G,MAAO9K,EAAO,EAAKiS,gBAG3CwB,EACU,eAAdvC,GAAyC,eAAXmC,EAE1BK,EAAsB,QAAdxC,EACRyC,EAAmBF,EAAelQ,EAAS,EACjD+P,EAAetT,GAASqQ,EAAQ,CAC9BpL,SAAU,WACV2O,KAAMF,OAAQ3X,EAAY4X,EAC1BE,MAAOH,EAAQC,OAAmB5X,EAClC+X,IAAML,EAAwB,EAATlQ,EACrBgN,OAASkD,EAAsB,OAAP1D,EACxBO,MAAOmD,EAAe1D,EAAO,OAEhC,CAED,OAAOM,CACR,EA5T4B,EA8T7BkD,wBA9T6B,IA+T7BA,oBAAqBZ,EAAAA,EAAAA,IAAW,SAAC5S,EAAQgU,EAASC,GAAlB,MAAgC,CAAC,CAAjC,IA/TH,EAwW7BC,oBAAsB,SAACC,GACrB,MAAiDA,EAAMC,cAA/CvD,EAAR,EAAQA,YAAaS,EAArB,EAAqBA,WAAY+C,EAAjC,EAAiCA,YACjC,EAAKC,UAAS,SAAAC,GACZ,GAAIA,EAAU/B,eAAiBlB,EAI7B,OAAO,KAGT,IAAQH,EAAc,EAAKpG,MAAnBoG,UAEJqB,EAAelB,EACnB,GAAkB,QAAdH,EAKF,OAAQH,KACN,IAAK,WACHwB,GAAgBlB,EAChB,MACF,IAAK,sBACHkB,EAAe6B,EAAcxD,EAAcS,EAWjD,OALAkB,EAAe7V,KAAK6X,IAClB,EACA7X,KAAKiH,IAAI4O,EAAc6B,EAAcxD,IAGhC,CACLyB,aAAa,EACbC,gBACEgC,EAAU/B,aAAeA,EAAe,UAAY,WACtDA,aAAAA,EACAE,0BAA0B,EAE7B,GAAE,EAAK+B,2BACT,EAlZ4B,EAoZ7BC,kBAAoB,SAACP,GACnB,MAAkDA,EAAMC,cAAhDO,EAAR,EAAQA,aAAcC,EAAtB,EAAsBA,aAAcC,EAApC,EAAoCA,UACpC,EAAKP,UAAS,SAAAC,GACZ,GAAIA,EAAU/B,eAAiBqC,EAI7B,OAAO,KAIT,IAAMrC,EAAe7V,KAAK6X,IACxB,EACA7X,KAAKiH,IAAIiR,EAAWD,EAAeD,IAGrC,MAAO,CACLrC,aAAa,EACbC,gBACEgC,EAAU/B,aAAeA,EAAe,UAAY,WACtDA,aAAAA,EACAE,0BAA0B,EAE7B,GAAE,EAAK+B,2BACT,EA5a4B,EA8a7BK,gBAAkB,SAACC,GACjB,IAAQC,EAAa,EAAKjK,MAAlBiK,SAER,EAAK7C,UAAc4C,EAEK,mBAAbC,EACTA,EAASD,GAEG,MAAZC,GACoB,iBAAbA,GACPA,EAASvB,eAAe,aAExBuB,EAASC,QAAUF,EAEtB,EA5b4B,EA8b7BN,2BAA6B,WACa,OAApC,EAAKrC,4BACP/C,EAAc,EAAK+C,4BAGrB,EAAKA,2BAA6B3C,EAChC,EAAKyF,kBAngB0B,IAsgBlC,EAvc4B,EAyc7BA,kBAAoB,WAClB,EAAK9C,2BAA6B,KAElC,EAAKkC,SAAS,CAAEhC,aAAa,IAAS,WAGpC,EAAKkB,oBAAoB,EAAG,KAC7B,GACF,EAjd4B,CAE5B,EA7BH,cA+BS2B,yBAAP,SACEC,EACAb,GAIA,OAFAc,EAAoBD,EAAWb,GAC/BtC,EAAcmD,GACP,IACR,EAtCH,2BAwCEE,SAAA,SAAS9C,GACPA,EAAe7V,KAAK6X,IAAI,EAAGhC,GAE3BlX,KAAKgZ,UAAS,SAAAC,GACZ,OAAIA,EAAU/B,eAAiBA,EACtB,KAEF,CACLD,gBACEgC,EAAU/B,aAAeA,EAAe,UAAY,WACtDA,aAAcA,EACdE,0BAA0B,EAE7B,GAAEpX,KAAKmZ,2BACT,EAtDH,EAwDEc,aAAA,SAAatV,EAAeuV,QAAqC,IAArCA,IAAAA,EAAuB,QACjD,MAA8Bla,KAAKyP,MAA3B0K,EAAR,EAAQA,UAAWnC,EAAnB,EAAmBA,OACXd,EAAiBlX,KAAK+W,MAAtBG,aAERvS,EAAQtD,KAAK6X,IAAI,EAAG7X,KAAKiH,IAAI3D,EAAOwV,EAAY,IAKhD,IAAIC,EAAgB,EACpB,GAAIpa,KAAK6W,UAAW,CAClB,IAAM6C,EAAa1Z,KAAK6W,UAEtBuD,EADa,aAAXpC,EAEA0B,EAASX,YAAcW,EAASnE,YAC5BZ,IACA,EAGJ+E,EAASJ,aAAeI,EAASL,aAC7B1E,IACA,CAET,CAED3U,KAAKga,SACH1D,EACEtW,KAAKyP,MACL9K,EACAuV,EACAhD,EACAlX,KAAK4W,eACLwD,GAGL,EA3FH,EA6FEC,kBAAA,WACE,MAAmDra,KAAKyP,MAAhDoG,EAAR,EAAQA,UAAWsB,EAAnB,EAAmBA,oBAAqBa,EAAxC,EAAwCA,OAExC,GAAmC,iBAAxBb,GAAsD,MAAlBnX,KAAK6W,UAAmB,CACrE,IAAM6C,EAAa1Z,KAAK6W,UAEN,eAAdhB,GAAyC,eAAXmC,EAChC0B,EAAS1D,WAAamB,EAEtBuC,EAASH,UAAYpC,CAExB,CAEDnX,KAAKsa,qBACN,EA3GH,EA6GEC,mBAAA,WACE,MAA8Bva,KAAKyP,MAA3BoG,EAAR,EAAQA,UAAWmC,EAAnB,EAAmBA,OACnB,EAAmDhY,KAAK+W,MAAhDG,EAAR,EAAQA,aAER,GAFA,EAAsBE,0BAE4B,MAAlBpX,KAAK6W,UAAmB,CACtD,IAAM6C,EAAa1Z,KAAK6W,UAGxB,GAAkB,eAAdhB,GAAyC,eAAXmC,EAChC,GAAkB,QAAdnC,EAIF,OAAQH,KACN,IAAK,WACHgE,EAAS1D,YAAckB,EACvB,MACF,IAAK,qBACHwC,EAAS1D,WAAakB,EACtB,MACF,QACE,IAAQ3B,EAA6BmE,EAA7BnE,YAAawD,EAAgBW,EAAhBX,YACrBW,EAAS1D,WAAa+C,EAAcxD,EAAc2B,OAItDwC,EAAS1D,WAAakB,OAGxBwC,EAASH,UAAYrC,CAExB,CAEDlX,KAAKsa,qBACN,EA/IH,EAiJEE,qBAAA,WAC0C,OAApCxa,KAAK8W,4BACP/C,EAAc/T,KAAK8W,2BAEtB,EArJH,EAuJE2D,OAAA,WACE,MAiBIza,KAAKyP,MAhBPiL,EADF,EACEA,SACAC,EAFF,EAEEA,UACA9E,EAHF,EAGEA,UACAX,EAJF,EAIEA,OACA0F,EALF,EAKEA,SACAC,EANF,EAMEA,iBACAC,EAPF,EAOEA,aACAX,EARF,EAQEA,UACAY,EATF,EASEA,SATF,IAUEC,QAAAA,OAVF,MAUY/E,EAVZ,EAWE+B,EAXF,EAWEA,OACAiD,EAZF,EAYEA,iBACAC,EAbF,EAaEA,aACAlG,EAdF,EAcEA,MACAmG,EAfF,EAeEA,eACAlG,EAhBF,EAgBEA,MAEM+B,EAAgBhX,KAAK+W,MAArBC,YAGFoB,EACU,eAAdvC,GAAyC,eAAXmC,EAE1BH,EAAWO,EACbpY,KAAK4Y,oBACL5Y,KAAKoZ,kBAET,EAAgCpZ,KAAKob,oBAA9BC,EAAP,KAAmBC,EAAnB,KAEMC,EAAQ,GACd,GAAIpB,EAAY,EACd,IAAK,IAAIxV,EAAQ0W,EAAY1W,GAAS2W,EAAW3W,IAC/C4W,EAAMpQ,MACJ4J,EAAAA,EAAAA,eAAc2F,EAAU,CACtB7Q,KAAMkR,EACN7M,IAAK8M,EAAQrW,EAAOoW,GACpBpW,MAAAA,EACAqS,YAAamE,EAAiBnE,OAActW,EAC5CsU,MAAOhV,KAAK8X,cAAcnT,MAQlC,IAAM6W,EAAqBpF,EACzBpW,KAAKyP,MACLzP,KAAK4W,gBAGP,OAAO7B,EAAAA,EAAAA,eACLkG,GAAoBC,GAAgB,MACpC,CACEP,UAAAA,EACA9C,SAAAA,EACA4B,IAAKzZ,KAAKwZ,gBACVxE,OAAO,QACLpL,SAAU,WACVsL,OAAAA,EACAD,MAAAA,EACAE,SAAU,OACVsG,wBAAyB,QACzBC,WAAY,YACZ7F,UAAAA,GACGb,KAGPD,EAAAA,EAAAA,eAAc8F,GAAoBC,GAAgB,MAAO,CACvDJ,SAAUa,EACV9B,IAAKmB,EACL5F,MAAO,CACLE,OAAQkD,EAAe,OAASoD,EAChCG,cAAe3E,EAAc,YAAStW,EACtCuU,MAAOmD,EAAeoD,EAAqB,UAIlD,EAvOH,EAgRElB,oBAAA,WACE,GAA0C,mBAA/Bta,KAAKyP,MAAMkI,iBACE3X,KAAKyP,MAAnB0K,UACQ,EAAG,CACjB,MAKIna,KAAKob,oBAJP7D,EADF,KAEEC,EAFF,KAGEC,EAHF,KAIEC,EAJF,KAMA1X,KAAKqX,qBACHE,EACAC,EACAC,EACAC,EAEH,CAGH,GAAmC,mBAAxB1X,KAAKyP,MAAMoI,SAAyB,CAC7C,MAII7X,KAAK+W,MAHPE,EADF,EACEA,gBACAC,EAFF,EAEEA,aACAE,EAHF,EAGEA,yBAEFpX,KAAK4X,cACHX,EACAC,EACAE,EAEH,CACF,EA/SH,EA4VEgE,kBAAA,WACE,MAAqCpb,KAAKyP,MAAlC0K,EAAR,EAAQA,UAAWyB,EAAnB,EAAmBA,cACnB,EAAuD5b,KAAK+W,MAApDC,EAAR,EAAQA,YAAaC,EAArB,EAAqBA,gBAAiBC,EAAtC,EAAsCA,aAEtC,GAAkB,IAAdiD,EACF,MAAO,CAAC,EAAG,EAAG,EAAG,GAGnB,IAAMkB,EAAa9E,EACjBvW,KAAKyP,MACLyH,EACAlX,KAAK4W,gBAED0E,EAAY9E,EAChBxW,KAAKyP,MACL4L,EACAnE,EACAlX,KAAK4W,gBAKDiF,EACH7E,GAAmC,aAApBC,EAEZ,EADA5V,KAAK6X,IAAI,EAAG0C,GAEZE,EACH9E,GAAmC,YAApBC,EAEZ,EADA5V,KAAK6X,IAAI,EAAG0C,GAGlB,MAAO,CACLva,KAAK6X,IAAI,EAAGmC,EAAaQ,GACzBxa,KAAK6X,IAAI,EAAG7X,KAAKiH,IAAI6R,EAAY,EAAGmB,EAAYQ,IAChDT,EACAC,EAEH,EAjYH,GAA6BS,EAAAA,eAA7B,EAKSC,aAAe,CACpBnG,UAAW,MACXkF,cAAUra,EACVsX,OAAQ,WACR4D,cAAe,EACfT,gBAAgB,GAVpB,CA8eD,CAQD,IAAMpB,EAAsB,SAAC,EAAD,GAWjB,EATPW,SASO,EARP7E,UAQO,EAPPX,OAOO,EANP8C,OAMO,EALP8C,aAKO,EAJPI,aAIO,EAHPjG,MAGO,EADPjR,QA0EH,EC/sBKiY,EAAkB,SACtBxM,EACA9K,EACAuX,GAEA,IAAQnE,EAAetI,EAAfsI,SACAoE,EAAuCD,EAAvCC,gBAAiBC,EAAsBF,EAAtBE,kBAEzB,GAAIzX,EAAQyX,EAAmB,CAC7B,IAAIlU,EAAS,EACb,GAAIkU,GAAqB,EAAG,CAC1B,IAAMC,EAAeF,EAAgBC,GACrClU,EAASmU,EAAanU,OAASmU,EAAa3H,IAC7C,CAED,IAAK,IAAI9M,EAAIwU,EAAoB,EAAGxU,GAAKjD,EAAOiD,IAAK,CACnD,IAAI8M,EAASqD,EAAgCnQ,GAE7CuU,EAAgBvU,GAAK,CACnBM,OAAAA,EACAwM,KAAAA,GAGFxM,GAAUwM,CACX,CAEDwH,EAAcE,kBAAoBzX,CACnC,CAED,OAAOwX,EAAgBxX,EACxB,EAkCK2X,EAA8B,SAClC7M,EACAyM,EACAK,EACAC,EACAtU,GAEA,KAAOsU,GAAOD,GAAM,CAClB,IAAME,EAASD,EAAMnb,KAAKsH,OAAO4T,EAAOC,GAAO,GACzCE,EAAgBT,EAAgBxM,EAAOgN,EAAQP,GAAehU,OAEpE,GAAIwU,IAAkBxU,EACpB,OAAOuU,EACEC,EAAgBxU,EACzBsU,EAAMC,EAAS,EACNC,EAAgBxU,IACzBqU,EAAOE,EAAS,EAEnB,CAED,OAAID,EAAM,EACDA,EAAM,EAEN,CAEV,EAEKG,EAAmC,SACvClN,EACAyM,EACAvX,EACAuD,GAKA,IAHA,IAAQiS,EAAc1K,EAAd0K,UACJyC,EAAW,EAGbjY,EAAQwV,GACR8B,EAAgBxM,EAAO9K,EAAOuX,GAAehU,OAASA,GAEtDvD,GAASiY,EACTA,GAAY,EAGd,OAAON,EACL7M,EACAyM,EACA7a,KAAKiH,IAAI3D,EAAOwV,EAAY,GAC5B9Y,KAAKsH,MAAMhE,EAAQ,GACnBuD,EAEH,EAEKkO,EAAwB,SAAC,EAAD,GAGzB,IAFD+D,EAEC,EAFDA,UACAgC,EACC,EADDA,gBAAiBU,EAChB,EADgBA,kBAAmBT,EACnC,EADmCA,kBAElCU,EAA2B,EAQ/B,GAJIV,GAAqBjC,IACvBiC,EAAoBjC,EAAY,GAG9BiC,GAAqB,EAAG,CAC1B,IAAMC,EAAeF,EAAgBC,GACrCU,EAA2BT,EAAanU,OAASmU,EAAa3H,IAC/D,CAKD,OAAOoI,GAHoB3C,EAAYiC,EAAoB,GACHS,CAGzD,EAEKE,EAAmB7G,EAAoB,CAC3CC,cAAe,SACb1G,EACA9K,EACAuX,GAHa,OAIFD,EAAgBxM,EAAO9K,EAAOuX,GAAehU,MAJ3C,EAMfmO,YAAa,SACX5G,EACA9K,EACAuX,GAHW,OAIAA,EAAcC,gBAAgBxX,GAAO+P,IAJrC,EAMb0B,sBAAAA,EAEAE,8BAA+B,SAC7B7G,EACA9K,EACAuV,EACAhD,EACAgF,EACA9B,GAEA,IAAQvE,EAAqCpG,EAArCoG,UAAWX,EAA0BzF,EAA1ByF,OAAQ8C,EAAkBvI,EAAlBuI,OAAQ/C,EAAUxF,EAAVwF,MAI7BP,EAD6B,eAAdmB,GAAyC,eAAXmC,EACpB/C,EAAQC,EACjCmH,EAAeJ,EAAgBxM,EAAO9K,EAAOuX,GAI7CV,EAAqBpF,EAAsB3G,EAAOyM,GAElDc,EAAY3b,KAAK6X,IACrB,EACA7X,KAAKiH,IAAIkT,EAAqB9G,EAAM2H,EAAanU,SAE7C+U,EAAY5b,KAAK6X,IACrB,EACAmD,EAAanU,OAASwM,EAAO2H,EAAa3H,KAAO0F,GAcnD,OAXc,UAAVF,IAKAA,EAHAhD,GAAgB+F,EAAYvI,GAC5BwC,GAAgB8F,EAAYtI,EAEpB,OAEA,UAIJwF,GACN,IAAK,QACH,OAAO8C,EACT,IAAK,MACH,OAAOC,EACT,IAAK,SACH,OAAO5b,KAAK6b,MAAMD,GAAaD,EAAYC,GAAa,GAE1D,QACE,OAAI/F,GAAgB+F,GAAa/F,GAAgB8F,EACxC9F,EACEA,EAAe+F,EACjBA,EAEAD,EAGd,EAEDzG,uBAAwB,SACtB9G,EACAvH,EACAgU,GAHsB,OArLF,SACtBzM,EACAyM,EACAhU,GAEA,IAAQiU,EAAuCD,EAAvCC,gBAAiBC,EAAsBF,EAAtBE,kBAKzB,OAFEA,EAAoB,EAAID,EAAgBC,GAAmBlU,OAAS,IAExCA,EAErBoU,EACL7M,EACAyM,EACAE,EACA,EACAlU,GAMKyU,EACLlN,EACAyM,EACA7a,KAAK6X,IAAI,EAAGkD,GACZlU,EAGL,CA2JciV,CAAgB1N,EAAOyM,EAAehU,EAJ3B,EAMxBsO,0BAA2B,SACzB/G,EACA4L,EACAnE,EACAgF,GAaA,IAXA,IAAQrG,EAAgDpG,EAAhDoG,UAAWX,EAAqCzF,EAArCyF,OAAQiF,EAA6B1K,EAA7B0K,UAAWnC,EAAkBvI,EAAlBuI,OAAQ/C,EAAUxF,EAAVwF,MAIxCP,EAD6B,eAAdmB,GAAyC,eAAXmC,EACpB/C,EAAQC,EACjCmH,EAAeJ,EAAgBxM,EAAO4L,EAAYa,GAClDc,EAAY9F,EAAexC,EAE7BxM,EAASmU,EAAanU,OAASmU,EAAa3H,KAC5C4G,EAAYD,EAETC,EAAYnB,EAAY,GAAKjS,EAAS8U,GAC3C1B,IACApT,GAAU+T,EAAgBxM,EAAO6L,EAAWY,GAAexH,KAG7D,OAAO4G,CACR,EAED7E,kBAxG2C,SAwGzBhH,EAAmBzL,GACnC,IAEMkY,EAAgB,CACpBC,gBAAiB,CAAC,EAClBU,kBAJ8BpN,EAAxBoN,mBAxQwB,GA6Q9BT,mBAAoB,GAuBtB,OApBApY,EAASoZ,gBAAkB,SACzBzY,EACA0Y,QACG,IADHA,IAAAA,GAA8B,GAE9BnB,EAAcE,kBAAoB/a,KAAKiH,IACrC4T,EAAcE,kBACdzX,EAAQ,GAOVX,EAASkU,oBAAoB,GAEzBmF,GACFrZ,EAASsZ,aAEZ,EAEMpB,CACR,EAEDxF,uCAAuC,EAEvCC,cAAe,YAAoC,EAAjCoB,QAUjB,G","sources":["webpack:///../../../node_modules/@cornerstonejs/calculate-suv/src/combineDateTime.ts","webpack:///../../../node_modules/@cornerstonejs/calculate-suv/src/parseDA.ts","webpack:///../../../node_modules/@cornerstonejs/calculate-suv/src/parseTM.ts","webpack:///../../../node_modules/@cornerstonejs/calculate-suv/src/dateTimeToFullDateInterface.ts","webpack:///../../../node_modules/@cornerstonejs/calculate-suv/src/calculateSUVScalingFactors.ts","webpack:///../../../node_modules/@cornerstonejs/calculate-suv/src/calculateScanTimes.ts","webpack:///../../../node_modules/@cornerstonejs/calculate-suv/src/calculateStartTime.ts","webpack:///../../../node_modules/@cornerstonejs/calculate-suv/src/calculateSUVbsaScalingFactor.ts","webpack:///../../../node_modules/@cornerstonejs/calculate-suv/src/calculateSUVlbmScalingFactor.ts","webpack:///../../../node_modules/dicomweb-client/src/message.js","webpack:///../../../node_modules/dicomweb-client/src/api.js","webpack:///../../../node_modules/dicomweb-client/src/version.js","webpack:///../../../node_modules/dicomweb-client/src/dicomweb-client.js","webpack:///../../../node_modules/react-window/src/timer.js","webpack:///../../../node_modules/react-window/src/domHelpers.js","webpack:///../../../node_modules/react-window/src/createGridComponent.js","webpack:///../../../node_modules/react-window/src/createListComponent.js","webpack:///../../../node_modules/react-window/src/VariableSizeList.js"],"sourcesContent":["import { DateInterface } from './parseDA';\nimport { TimeInterface } from './parseTM';\n\n/**\n * Javascript object that handles dates and compute the time.\n *\n * @export\n * @class FullDateInterface\n */\nexport class FullDateInterface {\n  fullDate: string;\n\n  /**\n   * Creates an instance of FullDateInterface.\n   * @param {string} date formatted as yyyy-mm-ddTHH:MM:SS.FFFFFFZ\n   * @memberof FullDateInterface\n   */\n  constructor(date: string) {\n    this.fullDate = date;\n  }\n\n  /**\n   * returns time since 1 january 1970\n   *\n   * @returns {number} time in sec\n   * @memberof FullDateInterface\n   */\n  getTimeInSec(): number {\n    // yyyy-mm-ddTHH:MM:SS.FFFFFFZ\n    const dateString = this.fullDate.substring(0, 10);\n    const timeString = this.fullDate.substring(11, 28);\n\n    // yyyy-mm-dd\n    const yyyy = parseInt(dateString.substring(0, 4), 10);\n    const mm =\n      dateString.length >= 7\n        ? parseInt(dateString.substring(5, 7), 10)\n        : undefined;\n    const dd =\n      dateString.length >= 10\n        ? parseInt(dateString.substring(8, 10), 10)\n        : undefined;\n\n    if (\n      isNaN(yyyy) ||\n      (mm !== undefined && isNaN(mm)) ||\n      (dd !== undefined && isNaN(dd)) ||\n      yyyy > 3000 ||\n      (mm && (mm < 1 || mm > 12)) ||\n      (dd && (dd < 1 || dd > 31))\n    ) {\n      throw new Error(`invalid date '${dateString}'`);\n    }\n\n    const dateJS = new Date(`${dateString}T00:00:00.000000Z`);\n\n    // HHMMSS.FFFFFF\n    const HH = parseInt(timeString.substring(0, 2), 10);\n    const MM =\n      timeString.length >= 5\n        ? parseInt(timeString.substring(3, 5), 10)\n        : undefined;\n    const SS =\n      timeString.length >= 8\n        ? parseInt(timeString.substring(6, 8), 10)\n        : undefined;\n    const fractionalStr = timeString.substring(9, 15);\n    const FFFFFF = fractionalStr\n      ? parseInt(fractionalStr, 10) * Math.pow(10, -fractionalStr.length)\n      : undefined;\n\n    if (\n      isNaN(HH) ||\n      (MM !== undefined && isNaN(MM)) ||\n      (SS !== undefined && isNaN(SS)) ||\n      (FFFFFF !== undefined && isNaN(FFFFFF)) ||\n      HH < 0 ||\n      HH > 23 ||\n      (MM && (MM < 0 || MM > 59)) ||\n      (SS && (SS < 0 || SS > 59)) ||\n      (FFFFFF && (FFFFFF < 0 || FFFFFF > 999999))\n    ) {\n      throw new Error(`invalid time '${timeString}'`);\n    }\n\n    let timeInSec = dateJS.getTime() / 1000;\n\n    timeInSec += HH * 3600;\n    if (MM !== undefined) {\n      timeInSec += MM * 60;\n    }\n    if (SS !== undefined) {\n      timeInSec += SS;\n    }\n    if (FFFFFF !== undefined) {\n      timeInSec += FFFFFF;\n    }\n\n    return timeInSec;\n  }\n\n  /**\n   * returns time since 1 january 1970\n   *\n   * @returns {number} time in microsec\n   * @memberof FullDateInterface\n   */\n  getTimeInMicroSec(): number {\n    const timeInMicroSec = this.getTimeInSec() * 1e6;\n    return timeInMicroSec;\n  }\n}\n\nexport interface FullDateInterface {\n  date: string;\n}\n\n/**\n * Combines two javascript objects containing the date and time information\n *\n * @export\n * @param {DateInterface} date\n * @param {TimeInterface} time\n * @returns {FullDateInterface}\n */\nexport default function combineDateTime(\n  date: DateInterface,\n  time: TimeInterface\n): FullDateInterface {\n  const hours = `${time.hours || '00'}`.padStart(2, '0');\n  const minutes = `${time.minutes || '00'}`.padStart(2, '0');\n  const seconds = `${time.seconds || '00'}`.padStart(2, '0');\n  const month = `${date.month}`.padStart(2, '0');\n  const day = `${date.day}`.padStart(2, '0');\n  const fractionalSeconds = `${time.fractionalSeconds || '000000'}`.padEnd(\n    6,\n    '0'\n  );\n  const dateString = `${date.year}-${month}-${day}`;\n  const timeString = `T${hours}:${minutes}:${seconds}.${fractionalSeconds}Z`;\n  const fullDateString = `${dateString}${timeString}`;\n\n  return new FullDateInterface(fullDateString);\n}\n\nexport { combineDateTime };\n","/**\n * Check the number of days for a picked month and year\n * algorithm based on http://stackoverflow.com/questions/1433030/validate-number-of-days-in-a-given-month\n *\n * @param {number} m\n * @param {number} y\n * @returns {number} number of days\n */\nfunction daysInMonth(m: number, y: number): number {\n  // m is 0 indexed: 0-11\n  switch (m) {\n    case 2:\n      return (y % 4 === 0 && y % 100) || y % 400 === 0 ? 29 : 28;\n    case 9:\n    case 4:\n    case 6:\n    case 11:\n      return 30;\n    default:\n      return 31;\n  }\n}\n\n/**\n * Check if the date is valid\n *\n * @param {number} d\n * @param {number} m\n * @param {number} y\n * @returns {boolean} boolean result\n */\nfunction isValidDate(d: number, m: number, y: number): boolean {\n  // make year is a number\n  if (isNaN(y)) {\n    return false;\n  }\n\n  return m > 0 && m <= 12 && d > 0 && d <= daysInMonth(m, y);\n}\n\n/**\n * Javascript object with properties year, month and day\n *\n * @export\n * @interface DateInterface\n */\nexport interface DateInterface {\n  year: number;\n  month: number;\n  day: number;\n}\n\n/**\n * Parses a DA formatted string into a Javascript object\n * @param {string} date a string in the DA VR format\n * @param {boolean} [validate] - true if an exception should be thrown if the date is invalid\n * @returns {DateInterface} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long\n */\nexport default function parseDA(date: string): DateInterface {\n  if (\n    date === undefined ||\n    date === null ||\n    date.length !== 8 ||\n    typeof date !== 'string'\n  ) {\n    throw new Error(`invalid DA '${date}'`);\n  }\n\n  const yyyy = parseInt(date.substring(0, 4), 10);\n  const mm = parseInt(date.substring(4, 6), 10);\n  const dd = parseInt(date.substring(6, 8), 10);\n\n  if (isValidDate(dd, mm, yyyy) !== true) {\n    throw new Error(`invalid DA '${date}'`);\n  }\n\n  return {\n    year: yyyy,\n    month: mm,\n    day: dd,\n  };\n}\n\nexport { parseDA };\n","/**\n * Javascript object with properties for hours, minutes, seconds and fractionalSeconds\n *\n * @export\n * @interface TimeInterface\n */\nexport interface TimeInterface {\n  hours?: number;\n  minutes?: number;\n  seconds?: number;\n  fractionalSeconds?: number;\n}\n\n/**\n * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds\n * @param {string} time - a string in the TM VR format\n * @returns {string} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined\n */\nexport default function parseTM(time: string): TimeInterface {\n  if (\n    time === null ||\n    time === undefined ||\n    time.length < 2 ||\n    typeof time !== 'string'\n  ) {\n    // must at least have HH\n    throw new Error(`invalid TM '${time}'`);\n  }\n\n  // 0123456789\n  // HHMMSS.FFFFFF\n  const hh = parseInt(time.substring(0, 2), 10);\n  const mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;\n  const ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;\n  const fractionalStr = time.length >= 8 ? time.substring(7, 13) : undefined;\n  const ffffff = fractionalStr\n    ? parseInt(fractionalStr, 10) * Math.pow(10, 6 - fractionalStr.length)\n    : undefined;\n\n  if (\n    isNaN(hh) ||\n    (mm !== undefined && isNaN(mm)) ||\n    (ss !== undefined && isNaN(ss)) ||\n    (ffffff !== undefined && isNaN(ffffff)) ||\n    hh < 0 ||\n    hh > 23 ||\n    (mm && (mm < 0 || mm > 59)) ||\n    (ss && (ss < 0 || ss > 59)) ||\n    (ffffff && (ffffff < 0 || ffffff > 999999))\n  ) {\n    throw new Error(`invalid TM '${time}'`);\n  }\n\n  return {\n    hours: hh,\n    minutes: mm,\n    seconds: ss,\n    fractionalSeconds: ffffff,\n  };\n}\n\nexport { parseTM };\n","import combineDateTime, { FullDateInterface } from './combineDateTime';\nimport parseDA from './parseDA';\nimport parseTM from './parseTM';\n\n/**\n * Utility to create a FullDateInterface object given a string formatted as yyyy-mm-ddTHH:MM:SS.FFFFFFZ\n *\n * @export\n * @param {string} dateTime\n * @returns {FullDateInterface}\n */\nexport default function dateTimeToFullDateInterface(\n  dateTime: string\n): FullDateInterface {\n  if (dateTime === undefined || dateTime === null) {\n    throw new Error('dateTimeToFullDateInterface : dateTime not defined.');\n  }\n\n  const date = parseDA(dateTime.substring(0, 8));\n  const time = parseTM(dateTime.substring(8));\n  return combineDateTime(date, time);\n}\n\nexport { dateTimeToFullDateInterface };\n","import { FullDateInterface } from './combineDateTime';\nimport { calculateScanTimes } from './calculateScanTimes';\nimport {\n  calculateSUVlbmJanmahasatianScalingFactor,\n  calculateSUVlbmScalingFactor,\n  SUVlbmScalingFactorInput,\n} from './calculateSUVlbmScalingFactor';\nimport {\n  calculateSUVbsaScalingFactor,\n  SUVbsaScalingFactorInput,\n} from './calculateSUVbsaScalingFactor';\nimport { calculateStartTime } from './calculateStartTime';\nimport { InstanceMetadata } from './types';\n\n/**\n * Javascript object containing the SUV and SUL factors.\n * TODO, the result property names may changes\n *\n * @interface ScalingFactorResult\n */\ninterface ScalingFactorResult {\n  suvbw: number;\n  suvlbm?: number;\n  suvlbmJanma?: number;\n  suvbsa?: number;\n}\n\n/**\n * The injected dose used to calculate SUV is corrected for the\n * decay that occurs between the time of injection and the start of the scan\n *\n * @param {InstanceMetadata[]} instances\n * @returns {number[]}\n */\nfunction calculateDecayCorrection(instances: InstanceMetadata[]): number[] {\n  const {\n    RadionuclideTotalDose,\n    RadionuclideHalfLife,\n    RadiopharmaceuticalStartDateTime,\n    RadiopharmaceuticalStartTime,\n    SeriesDate,\n  } = instances[0];\n\n  if (RadionuclideTotalDose === undefined || RadionuclideTotalDose === null) {\n    throw new Error(\n      'calculateDecayCorrection : RadionuclideTotalDose value not found.'\n    );\n  }\n\n  if (RadionuclideHalfLife === undefined || RadionuclideHalfLife === null) {\n    throw new Error(\n      'calculateDecayCorrection : RadionuclideHalfLife value not found.'\n    );\n  }\n\n  const scanTimes: FullDateInterface[] = calculateScanTimes(instances);\n  const startTime: FullDateInterface = calculateStartTime({\n    RadiopharmaceuticalStartDateTime,\n    RadiopharmaceuticalStartTime,\n    SeriesDate,\n  });\n\n  return instances.map((_, index) => {\n    const scanTime = scanTimes[index];\n    const decayTimeInSec: number =\n      scanTime.getTimeInSec() - startTime.getTimeInSec();\n    if (decayTimeInSec < 0) {\n      throw new Error('Decay time cannot be less than zero');\n    }\n\n    const decayedDose: number =\n      RadionuclideTotalDose *\n      Math.pow(2, -decayTimeInSec / RadionuclideHalfLife);\n\n    return 1 / decayedDose;\n  });\n}\n\n/**\n *\n * @param a Simple value or array of simple values\n * @param b Simple value or array of simple values\n * @returns boolean true if the values are equal.\n */\nconst deepEquals = (\n  a: string | number | any[],\n  b: string | number | any[]\n): boolean => {\n  return (\n    a === b ||\n    (Array.isArray(a) &&\n      Array.isArray(b) &&\n      a.length === b.length &&\n      a.every((val, index) => val === b[index]))\n  );\n};\n\n/**\n * Calculate the SUV factor\n *\n * Note: Rescale Slope / Intercept must still be applied. These must be applied\n *       on a per-Frame basis, since some scanners may have different values per Frame.\n *\n * @export\n * @param {InstanceMetadata[]} instances\n * @returns {ScalingFactorResult[]}\n */\nexport default function calculateSUVScalingFactors(\n  instances: InstanceMetadata[]\n): ScalingFactorResult[] {\n  const {\n    CorrectedImage,\n    Units,\n    PhilipsPETPrivateGroup,\n    PatientWeight,\n    PatientSex,\n    PatientSize,\n  } = instances[0];\n\n  if (!CorrectedImage.includes('ATTN') || !CorrectedImage.includes('DECY')) {\n    throw new Error(\n      `CorrectedImage must contain \"ATTN\" and \"DECY\": ${CorrectedImage}`\n    );\n  }\n\n  // Sanity check that every instance provided has identical\n  // values for series-level metadata. If not, the provided\n  // data is invalid.\n  const isSingleSeries = instances.every(instance => {\n    return (\n      instance.Units === Units &&\n      deepEquals(instance.CorrectedImage, CorrectedImage) &&\n      instance.PatientWeight === PatientWeight &&\n      instance.PatientSex === PatientSex &&\n      instance.PatientSize === PatientSize &&\n      instance.RadionuclideHalfLife === instances[0].RadionuclideHalfLife &&\n      instance.RadionuclideTotalDose === instances[0].RadionuclideTotalDose &&\n      instance.DecayCorrection === instances[0].DecayCorrection &&\n      instance.SeriesDate === instances[0].SeriesDate &&\n      instance.SeriesTime === instances[0].SeriesTime\n    );\n  });\n\n  if (!isSingleSeries) {\n    throw new Error(\n      'The set of instances does not appear to come from one Series. Every instance must have identical values for series-level metadata properties'\n    );\n  }\n\n  // Treat null, undefined and zero as a missing PatientWeight.\n  if (!PatientWeight) {\n    throw new Error(\n      'PatientWeight value is missing. It is not possible to calculate the SUV factors'\n    );\n  }\n\n  let decayCorrectionArray: number[] = new Array(instances.length);\n  decayCorrectionArray = calculateDecayCorrection(instances);\n\n  let results: number[] = new Array(instances.length);\n  const weightInGrams: number = PatientWeight * 1000;\n\n  if (Units === 'BQML') {\n    results = decayCorrectionArray.map(function(value) {\n      return value * weightInGrams;\n    });\n  } else if (Units === 'CNTS') {\n    const hasValidSUVScaleFactor: boolean = instances.every(instance => {\n      return (\n        instance.PhilipsPETPrivateGroup &&\n        instance.PhilipsPETPrivateGroup?.SUVScaleFactor !== null &&\n        instance.PhilipsPETPrivateGroup?.SUVScaleFactor !== undefined &&\n        instance.PhilipsPETPrivateGroup?.SUVScaleFactor !== 0\n      );\n    });\n\n    const hasValidActivityConcentrationScaleFactor: boolean = instances.every(\n      instance => {\n        return (\n          instance.PhilipsPETPrivateGroup &&\n          !instance.PhilipsPETPrivateGroup?.SUVScaleFactor &&\n          instance.PhilipsPETPrivateGroup?.ActivityConcentrationScaleFactor !==\n            undefined &&\n          instance.PhilipsPETPrivateGroup?.ActivityConcentrationScaleFactor !==\n            0\n        );\n      }\n    );\n\n    //console.log(`hasValidSUVScaleFactor: ${hasValidSUVScaleFactor}`);\n    //console.log(`hasValidActivityConcentrationScaleFactor: ${hasValidActivityConcentrationScaleFactor}`);\n\n    if (hasValidSUVScaleFactor) {\n      results = instances.map(\n        // Added ! to tell Typescript that this can't be undefined, since we are testing it\n        // in the .every loop above.\n        instance => instance.PhilipsPETPrivateGroup!.SUVScaleFactor!\n      );\n    } else if (hasValidActivityConcentrationScaleFactor) {\n      // if (0x7053,0x1000) not present, but (0x7053,0x1009) is present, then (0x7053,0x1009) * Rescale Slope,\n      // scales pixels to Bq/ml, and proceed as if Units are BQML\n      results = instances.map((instance, index) => {\n        // Added ! to tell Typescript that this can't be undefined, since we are testing it\n        // in the .every loop above.\n        return (\n          instance.PhilipsPETPrivateGroup!.ActivityConcentrationScaleFactor! *\n          decayCorrectionArray[index] *\n          weightInGrams\n        );\n      });\n    } else {\n      throw new Error(\n        `Units are in CNTS, but PhilipsPETPrivateGroup has invalid values: ${JSON.stringify(\n          PhilipsPETPrivateGroup\n        )}`\n      );\n    }\n  } else if (Units === 'GML') {\n    // assumes that GML indicates SUVbw instead of SUVlbm\n    results.fill(1);\n  } else {\n    throw new Error(`Units has an invalid value: ${Units}`);\n  }\n\n  // get BSA\n  let suvbsaFactor: number | undefined;\n  if (PatientSize === null || PatientSize === undefined) {\n    console.warn(\n      'PatientSize value is missing. It is not possible to calculate the SUV bsa factors'\n    );\n  } else {\n    const sulInputs: SUVbsaScalingFactorInput = {\n      PatientWeight,\n      PatientSize,\n    };\n\n    suvbsaFactor = calculateSUVbsaScalingFactor(sulInputs);\n  }\n\n  // get LBM\n  let suvlbmFactor: number | undefined;\n  let suvlbmJenmaFactor: number | undefined;\n  if (PatientSize === null || PatientSize === undefined) {\n    console.warn(\n      'PatientSize value is missing. It is not possible to calculate the SUV lbm factors'\n    );\n  } else if (PatientSex === null || PatientSex === undefined) {\n    console.warn(\n      'PatientSex value is missing. It is not possible to calculate the SUV lbm factors'\n    );\n  } else {\n    const suvlbmInputs: SUVlbmScalingFactorInput = {\n      PatientWeight,\n      PatientSex,\n      PatientSize,\n    };\n\n    suvlbmFactor = calculateSUVlbmScalingFactor(suvlbmInputs);\n    suvlbmJenmaFactor = calculateSUVlbmJanmahasatianScalingFactor(suvlbmInputs);\n  }\n\n  return results.map(function(result, index) {\n    const factors: ScalingFactorResult = {\n      suvbw: result,\n    };\n\n    if (suvbsaFactor) {\n      // multiply for BSA\n      factors.suvbsa = decayCorrectionArray[index] * suvbsaFactor;\n    }\n\n    if (suvlbmFactor) {\n      // multiply for LBM\n      factors.suvlbm = decayCorrectionArray[index] * suvlbmFactor;\n    }\n\n    if (suvlbmJenmaFactor) {\n      factors.suvlbmJanma = decayCorrectionArray[index] * suvlbmJenmaFactor;\n    }\n\n    // factor formulaes taken from:\n    // https://www.medicalconnections.co.uk/kb/calculating-suv-from-pet-images/\n\n    return factors;\n  });\n}\n\nexport { calculateSUVScalingFactors };\n","import combineDateTime, { FullDateInterface } from './combineDateTime';\nimport parseDA, { DateInterface } from './parseDA';\nimport parseTM, { TimeInterface } from './parseTM';\nimport dateTimeToFullDateInterface from './dateTimeToFullDateInterface';\n\n/**\n * Javascript object with scan properties\n *\n * @interface InstanceMetadataForScanTimes\n */\ninterface InstanceMetadataForScanTimes {\n  SeriesDate: string;\n  SeriesTime: string;\n  AcquisitionDate: string;\n  AcquisitionTime: string;\n\n  GEPrivatePostInjectionDateTime?: string;\n\n  // Only used in Siemens case\n  RadionuclideHalfLife?: number; // \tRadionuclideHalfLife(0x0018,0x1075)\tin\tRadiopharmaceutical\tInformation\tSequence(0x0054,0x0016)\n  RadionuclideTotalDose?: number;\n  FrameReferenceTime?: number;\n  ActualFrameDuration?: number;\n}\n\n/**\n * Calculate the scan times\n *\n * @export\n * @param {InstanceMetadataForScanTimes[]} instances\n * @returns {FullDateInterface[]}\n */\nexport default function calculateScanTimes(\n  instances: InstanceMetadataForScanTimes[]\n): FullDateInterface[] {\n  const {\n    SeriesDate,\n    SeriesTime,\n    GEPrivatePostInjectionDateTime,\n  } = instances[0];\n  const results = new Array(instances.length);\n  const seriesDate: DateInterface = parseDA(SeriesDate);\n  const seriesTime: TimeInterface = parseTM(SeriesTime);\n  const seriesDateTime: FullDateInterface = combineDateTime(\n    seriesDate,\n    seriesTime\n  );\n\n  let earliestAcquisitionDateTime = new FullDateInterface(\n    `3000-01-01T00:00:00.000000Z`\n  );\n  let timeError = earliestAcquisitionDateTime.getTimeInSec();\n  instances.forEach(instance => {\n    const { AcquisitionDate, AcquisitionTime } = instance;\n\n    const acquisitionDate: DateInterface = parseDA(AcquisitionDate);\n    const acquisitionTime: TimeInterface = parseTM(AcquisitionTime);\n    const acquisitionDateTime: FullDateInterface = combineDateTime(\n      acquisitionDate,\n      acquisitionTime\n    );\n\n    if (earliestAcquisitionDateTime.getTimeInSec() >= timeError) {\n      earliestAcquisitionDateTime = acquisitionDateTime;\n    } else {\n      earliestAcquisitionDateTime =\n        acquisitionDateTime.getTimeInSec() <\n        earliestAcquisitionDateTime.getTimeInSec()\n          ? acquisitionDateTime\n          : earliestAcquisitionDateTime;\n    }\n  });\n\n  if (earliestAcquisitionDateTime.getTimeInSec() >= timeError) {\n    throw new Error('Earliest acquisition time or date could not be parsed.');\n  }\n\n  if (\n    seriesDateTime.getTimeInSec() <= earliestAcquisitionDateTime.getTimeInSec()\n  ) {\n    return results.fill(seriesDateTime);\n  } else {\n    if (GEPrivatePostInjectionDateTime) {\n      // GE Private scan\n      return results.fill(\n        dateTimeToFullDateInterface(GEPrivatePostInjectionDateTime)\n      );\n    } else {\n      /*const hasValidFrameTimes = instances.every(instance => {\n        return (\n          instance.FrameReferenceTime &&\n          instance.FrameReferenceTime > 0 &&\n          instance.ActualFrameDuration &&\n          instance.ActualFrameDuration > 0\n        );\n      });*/\n\n      // TODO: Temporarily commented out the checks and logic below to\n      // investigate the BQML_AC_DT_lessThan_S_DT_SIEMENS-instances case\n      //if (!hasValidFrameTimes) {\n      return results.fill(earliestAcquisitionDateTime);\n      //}\n\n      /* Siemens PETsyngo\t3.x\tmulti-injection logic\n      - backcompute\tfrom\tcenter\t(average\tcount\trate\t)\tof\ttime\twindow\tfor\tbed\tposition\t(frame)\tin\tseries (reliable\tin\tall\tcases)\n      - Acquisition\tDate\t(0x0008,0x0022)\tand\tTime\t(0x0008,0x0032) are\tthe\tstart\tof\tthe\tbed\tposition\t(frame)\n      - Frame\tReference\tTime\t(0x0054,0x1300) is\tthe\toffset\t(ms)\tfrom\tthe\tscan\tDate\tand\tTime we\twant\tto\tthe\taverage\tcount\trate\ttime\n      */\n      /*return instances.map(instance => {\n        const {\n          FrameReferenceTime,\n          ActualFrameDuration,\n          RadionuclideHalfLife,\n          AcquisitionDate,\n          AcquisitionTime,\n        } = instance;\n        // Some of these checks are only here because the compiler is complaining\n        // We could potentially use the ! operator instead\n        if (!FrameReferenceTime || FrameReferenceTime <= 0) {\n          throw new Error(\n            `FrameReferenceTime is invalid: ${FrameReferenceTime}`\n          );\n        }\n\n        if (!ActualFrameDuration || ActualFrameDuration <= 0) {\n          throw new Error(\n            `ActualFrameDuration is invalid: ${ActualFrameDuration}`\n          );\n        }\n\n        if (!RadionuclideHalfLife) {\n          throw new Error('RadionuclideHalfLife is required');\n        }\n\n        if (!AcquisitionDate) {\n          throw new Error('AcquisitionDate is required');\n        }\n\n        if (!AcquisitionTime) {\n          throw new Error('AcquisitionTime is required');\n        }\n\n        const acquisitionDate: DateInterface = parseDA(AcquisitionDate);\n        const acquisitionTime: TimeInterface = parseTM(AcquisitionTime);\n        const acquisitionDateTime: FullDateInterface = combineDateTime(\n          acquisitionDate,\n          acquisitionTime\n        );\n\n        const frameDurationInSec = ActualFrameDuration / 1000;\n        const decayConstant = Math.log(2) / RadionuclideHalfLife;\n        const decayDuringFrame = decayConstant * frameDurationInSec;\n        // TODO: double check this is correctly copied from QIBA pseudocode\n        const averageCountRateTimeWithinFrameInSec =\n          (1 / decayConstant) *\n          Math.log(decayDuringFrame / (1 - Math.exp(-decayConstant)));\n        const scanDateTimeAsNumber =\n          Number(acquisitionDateTime) -\n          FrameReferenceTime / 1000 +\n          averageCountRateTimeWithinFrameInSec;\n\n        const scanDate = new Date(scanDateTimeAsNumber);\n        console.log('SIEMENS PATH');\n        console.log(new Date(scanDateTimeAsNumber));\n        return scanDate;\n      });*/\n    }\n  }\n}\n\nexport { calculateScanTimes };\n","import combineDateTime, { FullDateInterface } from './combineDateTime';\nimport { parseDA, DateInterface } from './parseDA';\nimport { parseTM, TimeInterface } from './parseTM';\nimport dateTimeToFullDateInterface from './dateTimeToFullDateInterface';\n\n/**\n * Calculate start time\n *\n * @export\n * @param {{\n *   RadiopharmaceuticalStartDateTime?: string;\n *   RadiopharmaceuticalStartTime?: string;\n *   SeriesDate?: string;\n * }} input\n * @returns {FullDateInterface}\n */\nexport default function calculateStartTime(input: {\n  RadiopharmaceuticalStartDateTime?: string;\n  RadiopharmaceuticalStartTime?: string;\n  SeriesDate?: string;\n}): FullDateInterface {\n  const {\n    RadiopharmaceuticalStartDateTime,\n    RadiopharmaceuticalStartTime,\n    SeriesDate,\n  } = input;\n\n  let time: TimeInterface;\n  let date: DateInterface;\n  if (RadiopharmaceuticalStartDateTime) {\n    return dateTimeToFullDateInterface(RadiopharmaceuticalStartDateTime);\n  } else if (RadiopharmaceuticalStartTime && SeriesDate) {\n    // start Date\tis not explicit - assume\tsame as\tSeries Date;\n    // but consider\tspanning midnight\n    // TODO: do we need some logic to check if the scan went over midnight?\n    time = parseTM(RadiopharmaceuticalStartTime);\n    date = parseDA(SeriesDate);\n\n    return combineDateTime(date, time);\n  }\n\n  throw new Error(`Invalid input: ${input}`);\n}\n\nexport { calculateStartTime };\n","/**\n * Javascript object with patient properties size, sez, weight\n *\n * @export\n * @interface SUVbsaScalingFactorInput\n */\ninterface SUVbsaScalingFactorInput {\n  PatientSize: number;\n  PatientWeight: number;\n}\n\nfunction calculateSUVbsaScalingFactor(\n  inputs: SUVbsaScalingFactorInput\n): number {\n  const { PatientWeight, PatientSize } = inputs;\n\n  let BSA =\n    Math.pow(PatientWeight, 0.425) * Math.pow(PatientSize * 100, 0.725) * 71.84;\n\n  return BSA;\n}\n\nexport { calculateSUVbsaScalingFactor, SUVbsaScalingFactorInput };\n","/**\n * Javascript object with patient properties size, sez, weight\n *\n * @export\n * @interface SUVlbmScalingFactorInput\n */\ninterface SUVlbmScalingFactorInput {\n  PatientSize: number; // m\n  PatientSex: string; //'M' | 'F' | 'O';\n  PatientWeight: number; // Kg\n}\n\nfunction calculateSUVlbmScalingFactor(\n  inputs: SUVlbmScalingFactorInput\n): number {\n  const { PatientSex, PatientWeight, PatientSize } = inputs;\n\n  let LBM;\n  const weightSizeFactor = Math.pow(PatientWeight / (PatientSize * 100), 2);\n  // reference: https://www.medicalconnections.co.uk/kb/calculating-suv-from-pet-images/\n  if (PatientSex === 'F') {\n    LBM = 1.07 * PatientWeight - 148 * weightSizeFactor;\n  } else if (PatientSex === 'M') {\n    LBM = 1.1 * PatientWeight - 120 * weightSizeFactor;\n  } else {\n    throw new Error(`PatientSex is an invalid value: ${PatientSex}`);\n  }\n\n  return LBM * 1000; // convert in gr\n}\n\n/**\n * From https://link.springer.com/article/10.1007/s00259-014-2961-x\n * and https://link.springer.com/article/10.2165/00003088-200544100-00004\n * and\n * @param inputs\n * @returns\n */\nfunction calculateSUVlbmJanmahasatianScalingFactor(\n  inputs: SUVlbmScalingFactorInput\n): number {\n  const { PatientSex, PatientWeight, PatientSize } = inputs;\n\n  let LBM;\n  const bodyMassIndex = PatientWeight / Math.pow(PatientSize, 2);\n\n  if (PatientSex === 'F') {\n    LBM = (9270 * PatientWeight) / (8780 + 244 * bodyMassIndex);\n  } else if (PatientSex === 'M') {\n    LBM = (9270 * PatientWeight) / (6680 + 216 * bodyMassIndex);\n  } else {\n    throw new Error(`PatientSex is an invalid value: ${PatientSex}`);\n  }\n  return LBM * 1000; // convert in gr\n}\n\nexport {\n  calculateSUVlbmScalingFactor,\n  calculateSUVlbmJanmahasatianScalingFactor,\n  SUVlbmScalingFactorInput,\n};\n","/**\n * Converts a Uint8Array to a String.\n * @param {Uint8Array} array that should be converted\n * @param {Number} offset array offset in case only subset of array items should\n                   be extracted (default: 0)\n * @param {Number} limit maximum number of array items that should be extracted\n                   (defaults to length of array)\n * @returns {String}\n */\nfunction uint8ArrayToString(arr, offset = 0, limit) {\n  const itemLimit = limit || arr.length - offset;\n  let str = '';\n  for (let i = offset; i < offset + itemLimit; i++) {\n    str += String.fromCharCode(arr[i]);\n  }\n  return str;\n}\n\n/**\n * Converts a String to a Uint8Array.\n * @param {String} str string that should be converted\n * @returns {Uint8Array}\n */\nfunction stringToUint8Array(str) {\n  const arr = new Uint8Array(str.length);\n  for (let i = 0, j = str.length; i < j; i++) {\n    arr[i] = str.charCodeAt(i);\n  }\n  return arr;\n}\n\n/**\n * Identifies the boundary in a multipart/related message header.\n * @param {String} header message header\n * @returns {String} boundary\n */\nfunction identifyBoundary(header) {\n  const parts = header.split('\\r\\n');\n\n  for (let i = 0; i < parts.length; i++) {\n    if (parts[i].substr(0, 2) === '--') {\n      return parts[i];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Checks whether a given token is contained by a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be present\n * @param {Number} offset offset in message content from where search should start\n * @returns {Boolean} whether message contains token at offset\n */\nfunction containsToken(message, token, offset = 0) {\n  if (offset + token.length > message.length) {\n    return false;\n  }\n\n  let index = offset;\n  for (let i = 0; i < token.length; i++) {\n    if (token[i] !== message[index]) {\n      return false;\n    }\n\n    index += 1;\n  }\n  return true;\n}\n\n/**\n * Finds a given token in a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be found\n * @param {String} offset message body offset from where search should start\n * @returns {Boolean} whether message has a part at given offset or not\n */\nfunction findToken(message, token, offset = 0, maxSearchLength) {\n  let searchLength = message.length;\n  if (maxSearchLength) {\n    searchLength = Math.min(offset + maxSearchLength, message.length);\n  }\n\n  for (let i = offset; i < searchLength; i++) {\n    // If the first value of the message matches\n    // the first value of the token, check if\n    // this is the full token.\n    if (message[i] === token[0]) {\n      if (containsToken(message, token, i)) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Create a random GUID\n *\n * @return {string}\n */\nfunction guid() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n  return `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;\n}\n\n/**\n * @typedef {Object} MultipartEncodedData\n * @property {ArrayBuffer} data The encoded Multipart Data\n * @property {String} boundary The boundary used to divide pieces of the encoded data\n */\n\n/**\n * Encode one or more DICOM datasets into a single body so it can be\n * sent using the Multipart Content-Type.\n *\n * @param {ArrayBuffer[]} datasets Array containing each file to be encoded in the\n                          multipart body, passed as ArrayBuffers.\n * @param {String} [boundary] Optional string to define a boundary between each part\n                              of the multipart body. If this is not specified, a random\n                              GUID will be generated.\n * @return {MultipartEncodedData} The Multipart encoded data returned as an Object. This\n                                  contains both the data itself, and the boundary string\n                                  used to divide it.\n */\nfunction multipartEncode(\n  datasets,\n  boundary = guid(),\n  contentType = 'application/dicom',\n) {\n  const contentTypeString = `Content-Type: ${contentType}`;\n  const header = `\\r\\n--${boundary}\\r\\n${contentTypeString}\\r\\n\\r\\n`;\n  const footer = `\\r\\n--${boundary}--`;\n  const headerArray = stringToUint8Array(header);\n  const footerArray = stringToUint8Array(footer);\n  const headerLength = headerArray.length;\n  const footerLength = footerArray.length;\n\n  let length = 0;\n\n  // Calculate the total length for the final array\n  const contentArrays = datasets.map(datasetBuffer => {\n    const contentArray = new Uint8Array(datasetBuffer);\n    const contentLength = contentArray.length;\n\n    length += headerLength + contentLength + footerLength;\n\n    return contentArray;\n  });\n\n  // Allocate the array\n  const multipartArray = new Uint8Array(length);\n\n  // Set the initial header\n  multipartArray.set(headerArray, 0);\n\n  // Write each dataset into the multipart array\n  let position = 0;\n  contentArrays.forEach(contentArray => {\n    multipartArray.set(headerArray, position);\n    multipartArray.set(contentArray, position + headerLength);\n\n    position += headerLength + contentArray.length;\n  });\n\n  multipartArray.set(footerArray, position);\n\n  return {\n    data: multipartArray.buffer,\n    boundary,\n  };\n}\n\n/**\n * Decode a Multipart encoded ArrayBuffer and return the components as an Array.\n *\n * @param {ArrayBuffer} response Data encoded as a 'multipart/related' message\n * @returns {Array} The content\n */\nfunction multipartDecode(response) {\n  // Use the raw data if it is provided in an appropriate format\n  const message = ArrayBuffer.isView(response) ? response : new Uint8Array(response);\n\n  /* Set a maximum length to search for the header boundaries, otherwise\n       findToken can run for a long time\n    */\n  const maxSearchLength = 1000;\n\n  // First look for the multipart mime header\n  const separator = stringToUint8Array('\\r\\n\\r\\n');\n  const headerIndex = findToken(message, separator, 0, maxSearchLength);\n  if (headerIndex === -1) {\n    throw new Error('Response message has no multipart mime header');\n  }\n\n  const header = uint8ArrayToString(message, 0, headerIndex);\n  const boundaryString = identifyBoundary(header);\n  if (!boundaryString) {\n    throw new Error('Header of response message does not specify boundary');\n  }\n\n  const boundary = stringToUint8Array(boundaryString);\n  const boundaryLength = boundary.length;\n  const components = [];\n\n  let offset = boundaryLength;\n\n  // Loop until we cannot find any more boundaries\n  let boundaryIndex;\n\n  while (boundaryIndex !== -1) {\n    // Search for the next boundary in the message, starting\n    // from the current offset position\n    boundaryIndex = findToken(message, boundary, offset);\n\n    // If no further boundaries are found, stop here.\n    if (boundaryIndex === -1) {\n      break;\n    }\n\n    const headerTokenIndex = findToken(\n      message,\n      separator,\n      offset,\n      maxSearchLength,\n    );\n    if (headerTokenIndex === -1) {\n      throw new Error('Response message part has no mime header');\n    }\n    offset = headerTokenIndex + separator.length;\n\n    // Extract data from response message, excluding \"\\r\\n\"\n    const spacingLength = 2;\n    const data = response.slice(offset, boundaryIndex - spacingLength);\n\n    // Add the data to the array of results\n    components.push(data);\n\n    // Move the offset to the end of the current section,\n    // plus the identified boundary\n    offset = boundaryIndex + boundaryLength;\n  }\n\n  return components;\n}\n\nexport {\n  containsToken,\n  findToken,\n  identifyBoundary,\n  uint8ArrayToString,\n  stringToUint8Array,\n  multipartEncode,\n  multipartDecode,\n  guid,\n};\n","import { multipartEncode, multipartDecode } from './message.js';\n\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null;\n}\n\nfunction isEmptyObject(obj) {\n  return Object.keys(obj).length === 0 && obj.constructor === Object;\n}\n\nfunction areValidRequestHooks(requestHooks) {\n  const isValid =\n    Array.isArray(requestHooks) &&\n    requestHooks.every(\n      requestHook =>\n        typeof requestHook === 'function' && requestHook.length === 2,\n    );\n\n  if (!isValid) {\n    console.warn(\n      'Request hooks should have the following signature: ' +\n        'function requestHook(request, metadata) { return request; }',\n    );\n  }\n\n  return isValid;\n}\n\nconst getFirstResult = result => result[0];\n\nconst MEDIATYPES = {\n  DICOM: 'application/dicom',\n  DICOM_JSON: 'application/dicom+json',\n  OCTET_STREAM: 'application/octet-stream',\n  PDF: 'application/pdf',\n  JPEG: 'image/jpeg',\n  PNG: 'image/png',\n};\n\n/**\n * debugLog is a function that can be called with console.log arguments, and will\n * be conditionally displayed, only when debug logging is enabled.\n */\nlet debugLog = () => {};\n\n/**\n * @typedef { import(\"../types/types\").InstanceMetadata } InstanceMetadata\n */\n\n/**\n * A callback with the request instance and metadata information\n * of the currently request being executed that should necessarily\n * return the given request optionally modified.\n * @typedef {function} RequestHook\n * @param {XMLHttpRequest} request - The original XMLHttpRequest instance.\n * @param {object} metadata - The metadata used by the request.\n */\n\n/**\n * Class for interacting with DICOMweb RESTful services.\n */\nclass DICOMwebClient {\n  /**\n   * @constructor\n   * @param {Object} options\n   * @param {String} options.url - URL of the DICOMweb RESTful Service endpoint\n   * @param {String=} options.qidoURLPrefix - URL path prefix for QIDO-RS\n   * @param {String=} options.wadoURLPrefix - URL path prefix for WADO-RS\n   * @param {String=} options.stowURLPrefix - URL path prefix for STOW-RS\n   * @param {String=} options.username - Username\n   * @param {String=} options.password - Password\n   * @param {Object=} options.headers - HTTP headers\n   * @param {Array.<RequestHook>=} options.requestHooks - Request hooks.\n   * @param {Object=} options.verbose - print to console request warnings and errors, default true\n   * @param {Object=} options.debug - print to the console debug level information/status updates.\n   * @param {boolean|String} options.singlepart - retrieve singlepart for the named types.\n   * The available types are:  bulkdata, video, image.  true means all.\n   */\n  constructor(options) {\n    this.baseURL = options.url;\n    if (!this.baseURL) {\n      console.error('no DICOMweb base url provided - calls that require a URL will fail');\n    }\n\n    if ('username' in options) {\n      this.username = options.username;\n      if (!('password' in options)) {\n        console.error(\n          'no password provided to authenticate with DICOMweb service',\n        );\n      }\n      this.password = options.password;\n    }\n\n    if ('qidoURLPrefix' in options) {\n      debugLog(`use URL prefix for QIDO-RS: ${options.qidoURLPrefix}`);\n      this.qidoURL = `${this.baseURL}/${options.qidoURLPrefix}`;\n    } else {\n      this.qidoURL = this.baseURL;\n    }\n\n    if ('wadoURLPrefix' in options) {\n      debugLog(`use URL prefix for WADO-RS: ${options.wadoURLPrefix}`);\n      this.wadoURL = `${this.baseURL}/${options.wadoURLPrefix}`;\n    } else {\n      this.wadoURL = this.baseURL;\n    }\n\n    if ('stowURLPrefix' in options) {\n      debugLog(`use URL prefix for STOW-RS: ${options.stowURLPrefix}`);\n      this.stowURL = `${this.baseURL}/${options.stowURLPrefix}`;\n    } else {\n      this.stowURL = this.baseURL;\n    }\n\n    if (options.singlepart) {\n      debugLog('use singlepart', options.singlepart);\n      this.singlepart = options.singlepart === true ? 'bulkdata,video,image' : options.singlepart;\n    } else {\n      this.singlepart = '';\n    }\n\n    if ('requestHooks' in options) {\n      this.requestHooks = options.requestHooks;\n    }\n\n    // Headers to pass to requests.\n    this.headers = options.headers || {};\n\n    // Optional error interceptor callback to handle any failed request.\n    this.errorInterceptor = options.errorInterceptor || (() => undefined);\n\n    // Verbose - print to console request warnings and errors, default true\n    this.verbose = options.verbose !== false;\n\n    this.setDebug(options.debug);\n \n\n  }\n\n  /**\n   * Allows setting the debug log information. \n   * Note this is different from verbose in that verbose is whether to include warning/error information, defaulting to true\n   * \n   * @param {boolean} debugLevel \n   * @param {function} debugLogFunction to call with the debug output arguments. \n   */\n  setDebug(debugLevel = false, debugLogFunction = null) {\n    this.debugLevel = !!debugLevel;\n    debugLog = debugLogFunction || debugLevel ? console.log : () => {};\n  }\n\n  /**\n   * Gets debug flag\n   * \n   * @returns true if debug logging is enabled\n   */\n  getDebug() {\n    return this.debugLevel;\n  }\n \n  /**\n   * Sets verbose flag.\n   *\n   * @param {Boolean} verbose\n   */\n  setVerbose(verbose) {\n    this.verbose = verbose;\n  }\n\n  /**\n   * Gets verbose flag.\n   *\n   * @return {Boolean} verbose\n   */\n  getVerbose() {\n    return this.verbose;\n  }\n\n  static _parseQueryParameters(params = {}) {\n    let queryString = '?';\n    Object.keys(params).forEach((key, index) => {\n      if (index !== 0) {\n        queryString += '&';\n      }\n      queryString += `${key}=${encodeURIComponent(params[key])}`;\n    });\n    return queryString;\n  }\n\n  /**\n   * Performs an HTTP request.\n   *\n   * @param {String} url\n   * @param {String} method\n   * @param {Object} headers\n   * @param {Object} options\n   * @param {Array.<RequestHook>} options.requestHooks - Request hooks.\n   * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @return {*}\n   * @private\n   */\n  _httpRequest(url, method, headers = {}, options = {}) {\n    const { errorInterceptor, requestHooks } = this;\n\n    return new Promise((resolve, reject) => {\n      let request = options.request ? options.request : new XMLHttpRequest();\n\n      request.open(method, url, true);\n      if ('responseType' in options) {\n        request.responseType = options.responseType;\n      }\n\n      if (typeof headers === 'object') {\n        Object.keys(headers).forEach(key => {\n          request.setRequestHeader(key, headers[key]);\n        });\n      }\n\n      // now add custom headers from the user\n      // (e.g. access tokens)\n      const userHeaders = this.headers;\n      Object.keys(userHeaders).forEach(key => {\n        request.setRequestHeader(key, userHeaders[key]);\n      });\n\n      // Event triggered when upload starts\n      request.onloadstart = function onloadstart() {\n        debugLog('upload started: ', url)\n      };\n\n      // Event triggered when upload ends\n      request.onloadend = function onloadend() {\n        debugLog('upload finished')\n      };\n\n      // Handle response message\n      request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n          if (request.status === 200) {\n            const contentType = request.getResponseHeader('Content-Type');\n            // Automatically distinguishes between multipart and singlepart in an array buffer, and\n            // converts them into a consistent type.\n            if (contentType && contentType.indexOf('multipart') !== -1) {\n              resolve(multipartDecode(request.response));\n            } else if (request.responseType === 'arraybuffer') {\n              resolve([request.response]);\n            } else {\n              resolve(request.response);\n            }\n          } else if (request.status === 202) {\n            if (this.verbose) {\n              console.warn('some resources already existed: ', request);\n            }\n            resolve(request.response);\n          } else if (request.status === 204) {\n            if (this.verbose) {\n              console.warn('empty response for request: ', request);\n            }\n            resolve([]);\n          } else {\n            const error = new Error('request failed');\n            error.request = request;\n            error.response = request.response;\n            error.status = request.status;\n            if (this.verbose) {\n              console.error('request failed: ', request);\n              console.error(error);\n              console.error(error.response);\n            }\n\n            errorInterceptor(error);\n\n            reject(error);\n          }\n        }\n      };\n\n      // Event triggered while download progresses\n      if ('progressCallback' in options) {\n        if (typeof options.progressCallback === 'function') {\n          request.onprogress = options.progressCallback;\n        }\n      }\n\n      if (requestHooks && areValidRequestHooks(requestHooks)) {\n        const combinedHeaders = Object.assign({}, headers, this.headers);\n        const metadata = { method, url, headers: combinedHeaders };\n        const pipeRequestHooks = functions => args =>\n          functions.reduce((props, fn) => fn(props, metadata), args);\n        const pipedRequest = pipeRequestHooks(requestHooks);\n        request = pipedRequest(request);\n      }\n\n      // Add withCredentials to request if needed\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          request.withCredentials = true;\n        }\n      }\n\n      if ('data' in options) {\n        request.send(options.data);\n      } else {\n        request.send();\n      }\n    });\n  }\n\n  /**\n   * Performs an HTTP GET request.\n   *\n   * @param {String} url\n   * @param {Object} headers\n   * @param {Object} responseType\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGet(url, headers, responseType, progressCallback, withCredentials) {\n    return this._httpRequest(url, 'get', headers, {\n      responseType,\n      progressCallback,\n      withCredentials,\n    });\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with application/json\n   * media type.\n   *\n   * @param {String} url\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetApplicationJson(url, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n    const headers = { Accept: MEDIATYPES.DICOM_JSON };\n    const responseType = 'json';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with application/pdf\n   * media type.\n   *\n   * @param {String} url\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetApplicationPdf(url, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n    const headers = { Accept: MEDIATYPES.PDF };\n    const responseType = 'json';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with an image\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetImage(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'image/',\n      'image/*',\n      'image/jpeg',\n      'image/jp2',\n      'image/gif',\n      'image/png',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with a text\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetText(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'text/',\n      'text/*',\n      'text/html',\n      'text/plain',\n      'text/rtf',\n      'text/xml',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with a video\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetVideo(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'video/',\n      'video/*',\n      'video/mpeg',\n      'video/mp4',\n      'video/H265',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Asserts that a given media type is valid.\n   *\n   * @params {String} mediaType media type\n   */\n  static _assertMediaTypeIsValid(mediaType) {\n    if (!mediaType) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    const sepIndex = mediaType.indexOf('/');\n    if (sepIndex === -1) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    const mediaTypeType = mediaType.slice(0, sepIndex);\n    const types = ['application', 'image', 'text', 'video'];\n    if (!types.includes(mediaTypeType)) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    if (mediaType.slice(sepIndex + 1).includes('/')) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with an image media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange - Start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartImage(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    rendered = false,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    let supportedMediaTypes;\n    if (rendered) {\n      supportedMediaTypes = [\n        'image/jpeg',\n        'image/gif',\n        'image/png',\n        'image/jp2',\n      ];\n    } else {\n      supportedMediaTypes = {\n        '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n        '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.90': ['image/jp2'],\n        '1.2.840.10008.1.2.4.91': ['image/jp2'],\n        '1.2.840.10008.1.2.4.92': ['image/jpx'],\n        '1.2.840.10008.1.2.4.93': ['image/jpx'],\n      };\n\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with a video media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange - Start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartVideo(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    rendered = false,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    let supportedMediaTypes;\n    if (rendered) {\n      supportedMediaTypes = [\n        'video/',\n        'video/*',\n        'video/mpeg2',\n        'video/mp4',\n        'video/H265',\n      ];\n    } else {\n      supportedMediaTypes = {\n        '1.2.840.10008.1.2.4.100': ['video/mpeg2'],\n        '1.2.840.10008.1.2.4.101': ['video/mpeg2'],\n        '1.2.840.10008.1.2.4.102': ['video/mp4'],\n        '1.2.840.10008.1.2.4.103': ['video/mp4'],\n        '1.2.840.10008.1.2.4.104': ['video/mp4'],\n        '1.2.840.10008.1.2.4.105': ['video/mp4'],\n        '1.2.840.10008.1.2.4.106': ['video/mp4'],\n      };\n\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message\n   * with a application/dicom media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartApplicationDicom(\n    url,\n    mediaTypes,\n    params,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    const defaultMediaType = 'application/dicom';\n    const supportedMediaTypes = {\n      '1.2.840.10008.1.2.1': [defaultMediaType],\n      '1.2.840.10008.1.2.5': [defaultMediaType],\n      '1.2.840.10008.1.2.4.50': [defaultMediaType],\n      '1.2.840.10008.1.2.4.51': [defaultMediaType],\n      '1.2.840.10008.1.2.4.57': [defaultMediaType],\n      '1.2.840.10008.1.2.4.70': [defaultMediaType],\n      '1.2.840.10008.1.2.4.80': [defaultMediaType],\n      '1.2.840.10008.1.2.4.81': [defaultMediaType],\n      '1.2.840.10008.1.2.4.90': [defaultMediaType],\n      '1.2.840.10008.1.2.4.91': [defaultMediaType],\n      '1.2.840.10008.1.2.4.92': [defaultMediaType],\n      '1.2.840.10008.1.2.4.93': [defaultMediaType],\n      '1.2.840.10008.1.2.4.100': [defaultMediaType],\n      '1.2.840.10008.1.2.4.101': [defaultMediaType],\n      '1.2.840.10008.1.2.4.102': [defaultMediaType],\n      '1.2.840.10008.1.2.4.103': [defaultMediaType],\n      '1.2.840.10008.1.2.4.104': [defaultMediaType],\n      '1.2.840.10008.1.2.4.105': [defaultMediaType],\n      '1.2.840.10008.1.2.4.106': [defaultMediaType],\n    };\n\n    let acceptableMediaTypes = mediaTypes;\n    if (!mediaTypes) {\n      acceptableMediaTypes = [{ mediaType: defaultMediaType }];\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      acceptableMediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message\n   * with a application/octet-stream, OR any of the equivalencies for that (eg\n   * application/pdf etc)\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartApplicationOctetStream(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    const defaultMediaType = 'application/octet-stream';\n    const supportedMediaTypes = {\n      '1.2.840.10008.1.2.1': [...Object.values(MEDIATYPES)],\n    };\n\n    let acceptableMediaTypes = mediaTypes;\n    if (!mediaTypes) {\n      acceptableMediaTypes = [{ mediaType: defaultMediaType }];\n    }\n\n    if (byteRange) {\n      headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      acceptableMediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP POST request.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object} headers - HTTP header fields\n   * @param {Array} data - Data that should be stored\n   * @param {Function} progressCallback\n   * @param {Function} progressCallback\n   * @param {XMLHttpRequest} request - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @private\n   * @returns {Promise} Response\n   */\n  _httpPost(url, headers, data, progressCallback, withCredentials, request) {\n    return this._httpRequest(url, 'post', headers, {\n      data,\n      progressCallback,\n      withCredentials,\n      request,\n    });\n  }\n\n  /**\n   * Performs an HTTP POST request with content-type application/dicom+json.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object} headers - HTTP header fields\n   * @param {Array} data - Data that should be stored\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise} Response\n   */\n  _httpPostApplicationJson(url, data, progressCallback, withCredentials) {\n    const headers = { 'Content-Type': MEDIATYPES.DICOM_JSON };\n    return this._httpPost(\n      url,\n      headers,\n      data,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Parses media type and extracts its type and subtype.\n   *\n   * @param {String} mediaType - HTTP media type (e.g. image/jpeg)\n   * @private\n   * @returns {String[]} Media type and subtype\n   */\n  static _parseMediaType(mediaType) {\n    DICOMwebClient._assertMediaTypeIsValid(mediaType);\n\n    return mediaType.split('/');\n  }\n\n  /**\n   * Builds an accept header field value for HTTP GET request messages.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types\n   * @param {Object[]} supportedMediaTypes - Supported media types\n   * @return {*}\n   * @private\n   */\n  static _buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes) {\n    if (!Array.isArray(mediaTypes)) {\n      throw new Error('Acceptable media types must be provided as an Array');\n    }\n\n    const fieldValueParts = mediaTypes.map(item => {\n      const { mediaType } = item;\n\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      if (!supportedMediaTypes.includes(mediaType)) {\n        throw new Error(\n          `Media type ${mediaType} is not supported for requested resource`,\n        );\n      }\n\n      return mediaType;\n    });\n\n    return fieldValueParts.join(', ');\n  }\n\n  /**\n   * Builds an accept header field value for HTTP GET multipart request\n   * messages.  Will throw an exception if no media types are found which are acceptable,\n   * but will only log a verbose level message when types are specified which are\n   * not acceptable.  This allows requesting several types with having to know\n   * whether they are all acceptable or not.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types\n   * @param {Object[]} supportedMediaTypes - Supported media types\n   * @private\n   */\n  static _buildMultipartAcceptHeaderFieldValue(\n    mediaTypes,\n    supportedMediaTypes,\n  ) {\n    if (!Array.isArray(mediaTypes)) {\n      throw new Error('Acceptable media types must be provided as an Array');\n    }\n\n    if (!Array.isArray(supportedMediaTypes) && !isObject(supportedMediaTypes)) {\n      throw new Error(\n        'Supported media types must be provided as an Array or an Object',\n      );\n    }\n\n    const fieldValueParts = [];\n\n    mediaTypes.forEach(item => {\n      const { transferSyntaxUID, mediaType } = item;\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      let fieldValue = `multipart/related; type=\"${mediaType}\"`;\n\n      if (isObject(supportedMediaTypes)) {\n        // SupportedMediaTypes is a lookup table that maps Transfer Syntax UID\n        // to one or more Media Types\n        if (\n          !Object.values(supportedMediaTypes)\n            .flat(1)\n            .includes(mediaType)\n        ) {\n          if (!mediaType.endsWith('/*') || !mediaType.endsWith('/')) {\n            debugLog(\n              `Media type ${mediaType} is not supported for requested resource`,\n            );\n            return;\n          }\n        }\n\n        if (transferSyntaxUID) {\n          if (transferSyntaxUID !== '*') {\n            if (!Object.keys(supportedMediaTypes).includes(transferSyntaxUID)) {\n              throw new Error(\n                `Transfer syntax ${transferSyntaxUID} is not supported for requested resource`,\n              );\n            }\n\n            const expectedMediaTypes = supportedMediaTypes[transferSyntaxUID];\n\n            if (!expectedMediaTypes.includes(mediaType)) {\n              const actualType = DICOMwebClient._parseMediaType(mediaType)[0];\n              expectedMediaTypes.map(expectedMediaType => {\n                const expectedType = DICOMwebClient._parseMediaType(\n                  expectedMediaType,\n                )[0];\n                const haveSameType = actualType === expectedType;\n\n                if (\n                  haveSameType &&\n                  (mediaType.endsWith('/*') || mediaType.endsWith('/'))\n                ) {\n                  return;\n                }\n\n                throw new Error(\n                  `Transfer syntax ${transferSyntaxUID} is not supported for requested resource`,\n                );\n              });\n            }\n          }\n\n          fieldValue += `; transfer-syntax=${transferSyntaxUID}`;\n        }\n      } else if (\n        Array.isArray(supportedMediaTypes) &&\n        !supportedMediaTypes.includes(mediaType)\n      ) {\n        if( this.verbose ) {\n          console.warn(\n            `Media type ${mediaType} is not supported for requested resource`,\n          );\n        }\n        return;\n      }\n\n      fieldValueParts.push(fieldValue);\n    });\n\n    if( !fieldValueParts.length ) {\n      throw new Error(`No acceptable media types found among ${JSON.stringify(mediaTypes)}`);\n    }\n\n    return fieldValueParts.join(', ');\n  }\n\n  /**\n   * Builds a range header field value for HTTP GET request messages.\n   *\n   * @param {Array} byteRange - Start and end of byte range\n   * @returns {String} Range header field value\n   * @private\n   */\n  static _buildRangeHeaderFieldValue(byteRange = []) {\n    if (byteRange.length === 1) {\n      return `bytes=${byteRange[0]}-`;\n    }\n    if (byteRange.length === 2) {\n      return `bytes=${byteRange[0]}-${byteRange[1]}`;\n    }\n\n    return 'bytes=0-';\n  }\n\n  /**\n   * Gets types that are shared among acceptable media types.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @private\n   * @returns {String[]} Types that are shared among acceptable media types\n   */\n  static _getSharedMediaTypes(mediaTypes) {\n    const types = new Set();\n\n    if (!mediaTypes || !mediaTypes.length) {\n      return types;\n    }\n\n    mediaTypes.forEach(item => {\n      const { mediaType } = item;\n      const type = DICOMwebClient._parseMediaType(mediaType)[0];\n      types.add(`${type}/`);\n    });\n\n    return Array.from(types);\n  }\n\n  /**\n   * Gets common base type of acceptable media types and asserts that only\n   one type is specified. For example, ``(\"image/jpeg\", \"image/jp2\")``\n   will pass, but ``(\"image/jpeg\", \"video/mpeg2\")`` will raise an\n   exception.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @private\n   * @returns {String[]} Common media type, eg `image/` for the above example.\n   */\n  static _getCommonMediaType(mediaTypes) {\n    if (!mediaTypes || !mediaTypes.length) {\n      throw new Error('No acceptable media types provided');\n    }\n\n    const sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n    if (sharedMediaTypes.length === 0) {\n      throw new Error('No common acceptable media type could be identified.');\n    } else if (sharedMediaTypes.length > 1) {\n      throw new Error('Acceptable media types must have the same type.');\n    }\n\n    return sharedMediaTypes[0];\n  }\n\n  /**\n   * Searches for DICOM studies.\n   *\n   * @param {Object} options\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @return {Object[]} Study representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2)\n   */\n  searchForStudies(options = {}) {\n    debugLog('search for studies');\n    let withCredentials = false;\n    let url = `${this.qidoURL}/studies`;\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves metadata for a DICOM study.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                      belonging to the study\n   */\n  retrieveStudyMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of study metadata',\n      );\n    }\n    debugLog(`retrieve metadata of study ${options.studyInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Searches for DICOM series.\n   *\n   * @param {Object} options\n   * @param {Object} [options.studyInstanceUID] - Study Instance UID\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Object[]} Series representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2a)\n   */\n  searchForSeries(options = {}) {\n    let url = this.qidoURL;\n    if ('studyInstanceUID' in options) {\n      debugLog(`search series of study ${options.studyInstanceUID}`);\n      url += `/studies/${options.studyInstanceUID}`;\n    }\n    url += '/series';\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves metadata for a DICOM series.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                      belonging to the series\n   */\n  retrieveSeriesMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of series metadata',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of series metadata',\n      );\n    }\n\n    debugLog(`retrieve metadata of series ${options.seriesInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Searches for DICOM Instances.\n   *\n   * @param {Object} options\n   * @param {String} [options.studyInstanceUID] - Study Instance UID\n   * @param {String} [options.seriesInstanceUID] - Series Instance UID\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Object[]} Instance representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2b)\n   */\n  searchForInstances(options = {}) {\n    let url = this.qidoURL;\n    let withCredentials = false;\n    if ('studyInstanceUID' in options) {\n      url += `/studies/${options.studyInstanceUID}`;\n      if ('seriesInstanceUID' in options) {\n        debugLog(\n          `search for instances of series ${options.seriesInstanceUID}`,\n        );\n        url += `/series/${options.seriesInstanceUID}`;\n      } else {\n        debugLog(\n          `search for instances of study ${options.studyInstanceUID}`,\n        );\n      }\n    } else {\n      debugLog('search for instances');\n    }\n    url += '/instances';\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /** Returns a WADO-URI URL for an instance\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {String} WADO-URI URL\n   */\n  buildInstanceWadoURIUrl(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required.');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required.');\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error('SOP Instance UID is required.');\n    }\n\n    const contentType = options.contentType || MEDIATYPES.DICOM;\n    const transferSyntax = options.transferSyntax || '*';\n    const params = [];\n\n    params.push('requestType=WADO');\n    params.push(`studyUID=${options.studyInstanceUID}`);\n    params.push(`seriesUID=${options.seriesInstanceUID}`);\n    params.push(`objectUID=${options.sopInstanceUID}`);\n    params.push(`contentType=${contentType}`);\n    params.push(`transferSyntax=${transferSyntax}`);\n\n    const paramString = params.join('&');\n\n    return `${this.wadoURL}?${paramString}`;\n  }\n\n  /**\n   * Retrieves metadata for a DICOM Instance.\n   *\n   * @param {Object} options object\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {Promise<InstanceMetadata>} metadata elements in DICOM JSON format\n   */\n  retrieveInstanceMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    debugLog(`retrieve metadata of instance ${options.sopInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves frames for a DICOM Instance.\n   * @param {Object} options options object\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @returns {Array} frame items as byte arrays of the pixel data element\n   */\n  retrieveInstanceFrames(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of instance frames',\n      );\n    }\n    debugLog(\n      `retrieve frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}`;\n\n    const { mediaTypes } = options;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n    if (sharedMediaTypes.length > 1) {\n      /**\n       * Enable request of frames that are stored either compressed\n       * (image/* media type) or uncompressed (application/octet-stream\n       * media type).\n       */\n      const supportedMediaTypes = {\n        '1.2.840.10008.1.2.1': ['application/octet-stream'],\n        '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n        '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.90': ['image/jp2'],\n        '1.2.840.10008.1.2.4.91': ['image/jp2'],\n        '1.2.840.10008.1.2.4.92': ['image/jpx'],\n        '1.2.840.10008.1.2.4.93': ['image/jpx'],\n        '1.2.840.10008.1.2.4.201': ['image/jhc'],\n        '1.2.840.10008.1.2.4.202': ['image/jhc'],\n      };\n\n      const headers = {\n        Accept: DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n          mediaTypes,\n          supportedMediaTypes,\n        ),\n      };\n      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n\n    if (commonMediaType.startsWith('application')) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        mediaTypes,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetMultipartImage(\n        url,\n        mediaTypes,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetMultipartVideo(\n        url,\n        mediaTypes,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of frames.`,\n    );\n  }\n\n /**\n * Element in mediaTypes parameter\n * @typedef {Object} MediaType\n * @param {String} [MediaType.mediaType] - ie 'image/jpeg', 'image/png'...\n */\n\n  /**\n   * Retrieves an individual, server-side rendered DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Promise<ArrayBuffer>} Rendered DICOM Instance\n   */\n  retrieveInstanceRendered(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance',\n      );\n    }\n\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/rendered`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetVideo(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('text')) {\n      return this._httpGetText(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType === MEDIATYPES.PDF) {\n      return this._httpGetApplicationPdf(\n        url,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered instance.',\n    );\n  }\n\n  /**\n   * Retrieves a thumbnail of an DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer} Thumbnail\n   */\n  retrieveInstanceThumbnail(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance',\n      );\n    }\n\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/thumbnail`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered instance.',\n    );\n  }\n\n  /**\n   * Retrieves rendered frames for a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n   */\n  retrieveInstanceFramesRendered(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of rendered instance frames',\n      );\n    }\n\n    debugLog(\n      `retrieve rendered frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}/rendered`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(url, headers, responseType, false, withCredentials);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetVideo(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered frame.',\n    );\n  }\n\n  /**\n   * Retrieves thumbnail of frames for a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n   */\n  retrieveInstanceFramesThumbnail(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of rendered instance frames',\n      );\n    }\n\n    console.debug(\n      `retrieve rendered frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}/thumbnail`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered frame.',\n    );\n  }\n\n  /**\n   * Retrieves a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {Promise<ArrayBuffer>} DICOM Part 10 file as Arraybuffer\n   */\n  retrieveInstance(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required');\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error('SOP Instance UID is required');\n    }\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}`;\n\n    const { mediaTypes } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      ).then(getFirstResult);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      ).then(getFirstResult);\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of instance.`,\n    );\n  }\n\n  /**\n   * Retrieves all DICOM Instances of a Series.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {Function} options.progressCallback\n   * @returns {Promise<ArrayBuffer[]>} DICOM Instances\n   */\n  retrieveSeries(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required');\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}`;\n\n    const { mediaTypes } = options;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of series.`,\n    );\n  }\n\n  /**\n   * Retrieves all DICOM Instances of a Study.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @returns {ArrayBuffer[]} DICOM Instances\n   */\n  retrieveStudy(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}`;\n\n    const { mediaTypes } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of study.`,\n    );\n  }\n\n  /**\n   * Retrieves and parses BulkData from a BulkDataURI location.\n   * Decodes the multipart encoded data and returns the resulting data\n   * as an ArrayBuffer.\n   *\n   * See http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.5.5.html\n   *\n   * @param {Object} options\n   * @param {string} options.BulkDataURI to retrieve\n   * @param {Array}  options.mediaTypes to use to fetch the URI\n   * @param {string} options.byteRange to request a sub-range (only valid on single part)\n   * @returns {Promise<Array>} Bulkdata parts\n   */\n  retrieveBulkData(options) {\n    if (!('BulkDataURI' in options)) {\n      throw new Error('BulkDataURI is required.');\n    }\n\n    const url = options.BulkDataURI;\n    const { mediaTypes, byteRange } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (this.singlepart.indexOf('bulkdata') !== -1) {\n      return this._httpGet(url, options.headers, 'arraybuffer', null, withCredentials);\n    }\n\n    if (mediaTypes) {\n      try {\n        const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n\n        if (commonMediaType==='image/') {\n          return this._httpGetMultipartImage(\n            url,\n            mediaTypes,\n            byteRange,\n            false,\n            false,\n            progressCallback,\n            withCredentials,\n          );\n        }\n      } catch(e) {\n        // No-op - this happens sometimes if trying to fetch the specific desired type but want to fallback to octet-stream\n      }\n    }\n\n    // Just use the media types provided\n    return this._httpGetMultipartApplicationOctetStream(\n      url,\n      mediaTypes,\n      byteRange,\n      false,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Stores DICOM Instances.\n   *\n   * @param {Object} options\n   * @param {ArrayBuffer[]} options.datasets - DICOM Instances in PS3.10 format\n   * @param {String} [options.studyInstanceUID] - Study Instance UID\n   * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @returns {Promise} Response message\n   */\n  storeInstances(options) {\n    if (!('datasets' in options)) {\n      throw new Error('datasets are required for storing');\n    }\n\n    let url = `${this.stowURL}/studies`;\n    if ('studyInstanceUID' in options) {\n      url += `/${options.studyInstanceUID}`;\n    }\n\n    const { data, boundary } = multipartEncode(options.datasets);\n    const headers = {\n      'Content-Type': `multipart/related; type=\"application/dicom\"; boundary=\"${boundary}\"`,\n    };\n    const { withCredentials = false } = options;\n    return this._httpPost(\n      url,\n      headers,\n      data,\n      options.progressCallback,\n      withCredentials,\n      options.request,\n    );\n  }\n\n  \n}\n\n\nexport { DICOMwebClient };\nexport default DICOMwebClient;\n","export default '0.5.2';\n","import { DICOMwebClient } from './api.js';\nimport {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n} from './utils.js';\n\nconst api = {\n  DICOMwebClient,\n};\nconst utils = {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n};\n\nexport { default as version } from './version.js';\n\nexport { api, utils };\n","// @flow\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\n\nconst hasNativePerformanceNow =\n  typeof performance === 'object' && typeof performance.now === 'function';\n\nconst now = hasNativePerformanceNow\n  ? () => performance.now()\n  : () => Date.now();\n\nexport type TimeoutID = {|\n  id: AnimationFrameID,\n|};\n\nexport function cancelTimeout(timeoutID: TimeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\n\nexport function requestTimeout(callback: Function, delay: number): TimeoutID {\n  const start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  const timeoutID: TimeoutID = {\n    id: requestAnimationFrame(tick),\n  };\n\n  return timeoutID;\n}\n","// @flow\n\nlet size: number = -1;\n\n// This utility copied from \"dom-helpers\" package.\nexport function getScrollbarSize(recalculate?: boolean = false): number {\n  if (size === -1 || recalculate) {\n    const div = document.createElement('div');\n    const style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n\n    ((document.body: any): HTMLBodyElement).appendChild(div);\n\n    size = div.offsetWidth - div.clientWidth;\n\n    ((document.body: any): HTMLBodyElement).removeChild(div);\n  }\n\n  return size;\n}\n\nexport type RTLOffsetType =\n  | 'negative'\n  | 'positive-descending'\n  | 'positive-ascending';\n\nlet cachedRTLResult: RTLOffsetType | null = null;\n\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nexport function getRTLOffsetType(recalculate?: boolean = false): RTLOffsetType {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement('div');\n    const outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n\n    const innerDiv = document.createElement('div');\n    const innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n\n    outerDiv.appendChild(innerDiv);\n\n    ((document.body: any): HTMLBodyElement).appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    ((document.body: any): HTMLBodyElement).removeChild(outerDiv);\n\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n","// @flow\n\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport { cancelTimeout, requestTimeout } from './timer';\nimport { getScrollbarSize, getRTLOffsetType } from './domHelpers';\n\nimport type { TimeoutID } from './timer';\n\ntype Direction = 'ltr' | 'rtl';\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\n\ntype itemSize = number | ((index: number) => number);\n\ntype RenderComponentProps<T> = {|\n  columnIndex: number,\n  data: T,\n  isScrolling?: boolean,\n  rowIndex: number,\n  style: Object,\n|};\nexport type RenderComponent<T> = React$ComponentType<\n  $Shape<RenderComponentProps<T>>\n>;\n\ntype ScrollDirection = 'forward' | 'backward';\n\ntype OnItemsRenderedCallback = ({\n  overscanColumnStartIndex: number,\n  overscanColumnStopIndex: number,\n  overscanRowStartIndex: number,\n  overscanRowStopIndex: number,\n  visibleColumnStartIndex: number,\n  visibleColumnStopIndex: number,\n  visibleRowStartIndex: number,\n  visibleRowStopIndex: number,\n}) => void;\ntype OnScrollCallback = ({\n  horizontalScrollDirection: ScrollDirection,\n  scrollLeft: number,\n  scrollTop: number,\n  scrollUpdateWasRequested: boolean,\n  verticalScrollDirection: ScrollDirection,\n}) => void;\n\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\ntype ItemStyleCache = { [key: string]: Object };\n\ntype OuterProps = {|\n  children: React$Node,\n  className: string | void,\n  onScroll: ScrollEvent => void,\n  style: {\n    [string]: mixed,\n  },\n|};\n\ntype InnerProps = {|\n  children: React$Node,\n  style: {\n    [string]: mixed,\n  },\n|};\n\nexport type Props<T> = {|\n  children: RenderComponent<T>,\n  className?: string,\n  columnCount: number,\n  columnWidth: itemSize,\n  direction: Direction,\n  height: number,\n  initialScrollLeft?: number,\n  initialScrollTop?: number,\n  innerRef?: any,\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\n  innerTagName?: string, // deprecated\n  itemData: T,\n  itemKey?: (params: {|\n    columnIndex: number,\n    data: T,\n    rowIndex: number,\n  |}) => any,\n  onItemsRendered?: OnItemsRenderedCallback,\n  onScroll?: OnScrollCallback,\n  outerRef?: any,\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\n  outerTagName?: string, // deprecated\n  overscanColumnCount?: number,\n  overscanColumnsCount?: number, // deprecated\n  overscanCount?: number, // deprecated\n  overscanRowCount?: number,\n  overscanRowsCount?: number, // deprecated\n  rowCount: number,\n  rowHeight: itemSize,\n  style?: Object,\n  useIsScrolling: boolean,\n  width: number,\n|};\n\ntype State = {|\n  instance: any,\n  isScrolling: boolean,\n  horizontalScrollDirection: ScrollDirection,\n  scrollLeft: number,\n  scrollTop: number,\n  scrollUpdateWasRequested: boolean,\n  verticalScrollDirection: ScrollDirection,\n|};\n\ntype getItemOffset = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype getItemSize = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype getEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\ntype GetOffsetForItemAndAlignment = (\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: any,\n  scrollbarSize: number\n) => number;\ntype GetStartIndexForOffset = (\n  props: Props<any>,\n  offset: number,\n  instanceProps: any\n) => number;\ntype GetStopIndexForStartIndex = (\n  props: Props<any>,\n  startIndex: number,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\ntype ValidateProps = (props: Props<any>) => void;\n\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nconst defaultItemKey = ({ columnIndex, data, rowIndex }) =>\n  `${rowIndex}:${columnIndex}`;\n\n// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nlet devWarningsOverscanCount = null;\nlet devWarningsOverscanRowsColumnsCount = null;\nlet devWarningsTagName = null;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = new WeakSet();\n    devWarningsOverscanRowsColumnsCount = new WeakSet();\n    devWarningsTagName = new WeakSet();\n  }\n}\n\nexport default function createGridComponent({\n  getColumnOffset,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getColumnWidth,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment,\n  getOffsetForRowAndAlignment,\n  getRowHeight,\n  getRowOffset,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange,\n  validateProps,\n}: {|\n  getColumnOffset: getItemOffset,\n  getColumnStartIndexForOffset: GetStartIndexForOffset,\n  getColumnStopIndexForStartIndex: GetStopIndexForStartIndex,\n  getColumnWidth: getItemSize,\n  getEstimatedTotalHeight: getEstimatedTotalSize,\n  getEstimatedTotalWidth: getEstimatedTotalSize,\n  getOffsetForColumnAndAlignment: GetOffsetForItemAndAlignment,\n  getOffsetForRowAndAlignment: GetOffsetForItemAndAlignment,\n  getRowOffset: getItemOffset,\n  getRowHeight: getItemSize,\n  getRowStartIndexForOffset: GetStartIndexForOffset,\n  getRowStopIndexForStartIndex: GetStopIndexForStartIndex,\n  initInstanceProps: InitInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange: boolean,\n  validateProps: ValidateProps,\n|}) {\n  return class Grid<T> extends PureComponent<Props<T>, State> {\n    _instanceProps: any = initInstanceProps(this.props, this);\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\n    _outerRef: ?HTMLDivElement;\n\n    static defaultProps = {\n      direction: 'ltr',\n      itemData: undefined,\n      useIsScrolling: false,\n    };\n\n    state: State = {\n      instance: this,\n      isScrolling: false,\n      horizontalScrollDirection: 'forward',\n      scrollLeft:\n        typeof this.props.initialScrollLeft === 'number'\n          ? this.props.initialScrollLeft\n          : 0,\n      scrollTop:\n        typeof this.props.initialScrollTop === 'number'\n          ? this.props.initialScrollTop\n          : 0,\n      scrollUpdateWasRequested: false,\n      verticalScrollDirection: 'forward',\n    };\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    constructor(props: Props<T>) {\n      super(props);\n    }\n\n    static getDerivedStateFromProps(\n      nextProps: Props<T>,\n      prevState: State\n    ): $Shape<State> | null {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    }\n\n    scrollTo({\n      scrollLeft,\n      scrollTop,\n    }: {\n      scrollLeft: number,\n      scrollTop: number,\n    }): void {\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(prevState => {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (\n          prevState.scrollLeft === scrollLeft &&\n          prevState.scrollTop === scrollTop\n        ) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection:\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection:\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n        };\n      }, this._resetIsScrollingDebounced);\n    }\n\n    scrollToItem({\n      align = 'auto',\n      columnIndex,\n      rowIndex,\n    }: {\n      align: ScrollToAlign,\n      columnIndex?: number,\n      rowIndex?: number,\n    }): void {\n      const { columnCount, height, rowCount, width } = this.props;\n      const { scrollLeft, scrollTop } = this.state;\n      const scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      const estimatedTotalHeight = getEstimatedTotalHeight(\n        this.props,\n        this._instanceProps\n      );\n      const estimatedTotalWidth = getEstimatedTotalWidth(\n        this.props,\n        this._instanceProps\n      );\n\n      // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n      const horizontalScrollbarSize =\n        estimatedTotalWidth > width ? scrollbarSize : 0;\n      const verticalScrollbarSize =\n        estimatedTotalHeight > height ? scrollbarSize : 0;\n\n      this.scrollTo({\n        scrollLeft:\n          columnIndex !== undefined\n            ? getOffsetForColumnAndAlignment(\n                this.props,\n                columnIndex,\n                align,\n                scrollLeft,\n                this._instanceProps,\n                verticalScrollbarSize\n              )\n            : scrollLeft,\n        scrollTop:\n          rowIndex !== undefined\n            ? getOffsetForRowAndAlignment(\n                this.props,\n                rowIndex,\n                align,\n                scrollTop,\n                this._instanceProps,\n                horizontalScrollbarSize\n              )\n            : scrollTop,\n      });\n    }\n\n    componentDidMount() {\n      const { initialScrollLeft, initialScrollTop } = this.props;\n\n      if (this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentDidUpdate() {\n      const { direction } = this.props;\n      const { scrollLeft, scrollTop, scrollUpdateWasRequested } = this.state;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n            default:\n              const { clientWidth, scrollWidth } = outerRef;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    }\n\n    render() {\n      const {\n        children,\n        className,\n        columnCount,\n        direction,\n        height,\n        innerRef,\n        innerElementType,\n        innerTagName,\n        itemData,\n        itemKey = defaultItemKey,\n        outerElementType,\n        outerTagName,\n        rowCount,\n        style,\n        useIsScrolling,\n        width,\n      } = this.props;\n      const { isScrolling } = this.state;\n\n      const [\n        columnStartIndex,\n        columnStopIndex,\n      ] = this._getHorizontalRangeToRender();\n      const [rowStartIndex, rowStopIndex] = this._getVerticalRangeToRender();\n\n      const items = [];\n      if (columnCount > 0 && rowCount) {\n        for (\n          let rowIndex = rowStartIndex;\n          rowIndex <= rowStopIndex;\n          rowIndex++\n        ) {\n          for (\n            let columnIndex = columnStartIndex;\n            columnIndex <= columnStopIndex;\n            columnIndex++\n          ) {\n            items.push(\n              createElement(children, {\n                columnIndex,\n                data: itemData,\n                isScrolling: useIsScrolling ? isScrolling : undefined,\n                key: itemKey({ columnIndex, data: itemData, rowIndex }),\n                rowIndex,\n                style: this._getItemStyle(rowIndex, columnIndex),\n              })\n            );\n          }\n        }\n      }\n\n      // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n      const estimatedTotalHeight = getEstimatedTotalHeight(\n        this.props,\n        this._instanceProps\n      );\n      const estimatedTotalWidth = getEstimatedTotalWidth(\n        this.props,\n        this._instanceProps\n      );\n\n      return createElement(\n        outerElementType || outerTagName || 'div',\n        {\n          className,\n          onScroll: this._onScroll,\n          ref: this._outerRefSetter,\n          style: {\n            position: 'relative',\n            height,\n            width,\n            overflow: 'auto',\n            WebkitOverflowScrolling: 'touch',\n            willChange: 'transform',\n            direction,\n            ...style,\n          },\n        },\n        createElement(innerElementType || innerTagName || 'div', {\n          children: items,\n          ref: innerRef,\n          style: {\n            height: estimatedTotalHeight,\n            pointerEvents: isScrolling ? 'none' : undefined,\n            width: estimatedTotalWidth,\n          },\n        })\n      );\n    }\n\n    _callOnItemsRendered: (\n      overscanColumnStartIndex: number,\n      overscanColumnStopIndex: number,\n      overscanRowStartIndex: number,\n      overscanRowStopIndex: number,\n      visibleColumnStartIndex: number,\n      visibleColumnStopIndex: number,\n      visibleRowStartIndex: number,\n      visibleRowStopIndex: number\n    ) => void;\n    _callOnItemsRendered = memoizeOne(\n      (\n        overscanColumnStartIndex: number,\n        overscanColumnStopIndex: number,\n        overscanRowStartIndex: number,\n        overscanRowStopIndex: number,\n        visibleColumnStartIndex: number,\n        visibleColumnStopIndex: number,\n        visibleRowStartIndex: number,\n        visibleRowStopIndex: number\n      ) =>\n        ((this.props.onItemsRendered: any): OnItemsRenderedCallback)({\n          overscanColumnStartIndex,\n          overscanColumnStopIndex,\n          overscanRowStartIndex,\n          overscanRowStopIndex,\n          visibleColumnStartIndex,\n          visibleColumnStopIndex,\n          visibleRowStartIndex,\n          visibleRowStopIndex,\n        })\n    );\n\n    _callOnScroll: (\n      scrollLeft: number,\n      scrollTop: number,\n      horizontalScrollDirection: ScrollDirection,\n      verticalScrollDirection: ScrollDirection,\n      scrollUpdateWasRequested: boolean\n    ) => void;\n    _callOnScroll = memoizeOne(\n      (\n        scrollLeft: number,\n        scrollTop: number,\n        horizontalScrollDirection: ScrollDirection,\n        verticalScrollDirection: ScrollDirection,\n        scrollUpdateWasRequested: boolean\n      ) =>\n        ((this.props.onScroll: any): OnScrollCallback)({\n          horizontalScrollDirection,\n          scrollLeft,\n          scrollTop,\n          verticalScrollDirection,\n          scrollUpdateWasRequested,\n        })\n    );\n\n    _callPropsCallbacks() {\n      const { columnCount, onItemsRendered, onScroll, rowCount } = this.props;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          const [\n            overscanColumnStartIndex,\n            overscanColumnStopIndex,\n            visibleColumnStartIndex,\n            visibleColumnStopIndex,\n          ] = this._getHorizontalRangeToRender();\n          const [\n            overscanRowStartIndex,\n            overscanRowStopIndex,\n            visibleRowStartIndex,\n            visibleRowStopIndex,\n          ] = this._getVerticalRangeToRender();\n          this._callOnItemsRendered(\n            overscanColumnStartIndex,\n            overscanColumnStopIndex,\n            overscanRowStartIndex,\n            overscanRowStopIndex,\n            visibleColumnStartIndex,\n            visibleColumnStopIndex,\n            visibleRowStartIndex,\n            visibleRowStopIndex\n          );\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        const {\n          horizontalScrollDirection,\n          scrollLeft,\n          scrollTop,\n          scrollUpdateWasRequested,\n          verticalScrollDirection,\n        } = this.state;\n        this._callOnScroll(\n          scrollLeft,\n          scrollTop,\n          horizontalScrollDirection,\n          verticalScrollDirection,\n          scrollUpdateWasRequested\n        );\n      }\n    }\n\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getItemStyle: (rowIndex: number, columnIndex: number) => Object;\n    _getItemStyle = (rowIndex: number, columnIndex: number): Object => {\n      const { columnWidth, direction, rowHeight } = this.props;\n\n      const itemStyleCache = this._getItemStyleCache(\n        shouldResetStyleCacheOnItemSizeChange && columnWidth,\n        shouldResetStyleCacheOnItemSizeChange && direction,\n        shouldResetStyleCacheOnItemSizeChange && rowHeight\n      );\n\n      const key = `${rowIndex}:${columnIndex}`;\n\n      let style;\n      if (itemStyleCache.hasOwnProperty(key)) {\n        style = itemStyleCache[key];\n      } else {\n        const offset = getColumnOffset(\n          this.props,\n          columnIndex,\n          this._instanceProps\n        );\n        const isRtl = direction === 'rtl';\n        itemStyleCache[key] = style = {\n          position: 'absolute',\n          left: isRtl ? undefined : offset,\n          right: isRtl ? offset : undefined,\n          top: getRowOffset(this.props, rowIndex, this._instanceProps),\n          height: getRowHeight(this.props, rowIndex, this._instanceProps),\n          width: getColumnWidth(this.props, columnIndex, this._instanceProps),\n        };\n      }\n\n      return style;\n    };\n\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\n\n    _getHorizontalRangeToRender(): [number, number, number, number] {\n      const {\n        columnCount,\n        overscanColumnCount,\n        overscanColumnsCount,\n        overscanCount,\n        rowCount,\n      } = this.props;\n      const { horizontalScrollDirection, isScrolling, scrollLeft } = this.state;\n\n      const overscanCountResolved: number =\n        overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getColumnStartIndexForOffset(\n        this.props,\n        scrollLeft,\n        this._instanceProps\n      );\n      const stopIndex = getColumnStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollLeft,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || horizontalScrollDirection === 'backward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n      const overscanForward =\n        !isScrolling || horizontalScrollDirection === 'forward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _getVerticalRangeToRender(): [number, number, number, number] {\n      const {\n        columnCount,\n        overscanCount,\n        overscanRowCount,\n        overscanRowsCount,\n        rowCount,\n      } = this.props;\n      const { isScrolling, verticalScrollDirection, scrollTop } = this.state;\n\n      const overscanCountResolved: number =\n        overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getRowStartIndexForOffset(\n        this.props,\n        scrollTop,\n        this._instanceProps\n      );\n      const stopIndex = getRowStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollTop,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || verticalScrollDirection === 'backward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n      const overscanForward =\n        !isScrolling || verticalScrollDirection === 'forward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _onScroll = (event: ScrollEvent): void => {\n      const {\n        clientHeight,\n        clientWidth,\n        scrollLeft,\n        scrollTop,\n        scrollHeight,\n        scrollWidth,\n      } = event.currentTarget;\n      this.setState(prevState => {\n        if (\n          prevState.scrollLeft === scrollLeft &&\n          prevState.scrollTop === scrollTop\n        ) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        const { direction } = this.props;\n\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n        // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n        let calculatedScrollLeft = scrollLeft;\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              calculatedScrollLeft = -scrollLeft;\n              break;\n            case 'positive-descending':\n              calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        calculatedScrollLeft = Math.max(\n          0,\n          Math.min(calculatedScrollLeft, scrollWidth - clientWidth)\n        );\n        const calculatedScrollTop = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        );\n\n        return {\n          isScrolling: true,\n          horizontalScrollDirection:\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: calculatedScrollTop,\n          verticalScrollDirection:\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _outerRefSetter = (ref: any): void => {\n      const { outerRef } = this.props;\n\n      this._outerRef = ((ref: any): HTMLDivElement);\n\n      if (typeof outerRef === 'function') {\n        outerRef(ref);\n      } else if (\n        outerRef != null &&\n        typeof outerRef === 'object' &&\n        outerRef.hasOwnProperty('current')\n      ) {\n        outerRef.current = ref;\n      }\n    };\n\n    _resetIsScrollingDebounced = () => {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._resetIsScrollingTimeoutId = requestTimeout(\n        this._resetIsScrolling,\n        IS_SCROLLING_DEBOUNCE_INTERVAL\n      );\n    };\n\n    _resetIsScrolling = () => {\n      this._resetIsScrollingTimeoutId = null;\n\n      this.setState({ isScrolling: false }, () => {\n        // Clear style cache after state update has been committed.\n        // This way we don't break pure sCU for items that don't use isScrolling param.\n        this._getItemStyleCache(-1);\n      });\n    };\n  };\n}\n\nconst validateSharedProps = (\n  {\n    children,\n    direction,\n    height,\n    innerTagName,\n    outerTagName,\n    overscanColumnsCount,\n    overscanCount,\n    overscanRowsCount,\n    width,\n  }: Props<any>,\n  { instance }: State\n): void => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn(\n          'The overscanCount prop has been deprecated. ' +\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\n        );\n      }\n    }\n\n    if (\n      typeof overscanColumnsCount === 'number' ||\n      typeof overscanRowsCount === 'number'\n    ) {\n      if (\n        devWarningsOverscanRowsColumnsCount &&\n        !devWarningsOverscanRowsColumnsCount.has(instance)\n      ) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn(\n          'The overscanColumnsCount and overscanRowsCount props have been deprecated. ' +\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\n        );\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn(\n          'The innerTagName and outerTagName props have been deprecated. ' +\n            'Please use the innerElementType and outerElementType props instead.'\n        );\n      }\n    }\n\n    if (children == null) {\n      throw Error(\n        'An invalid \"children\" prop has been specified. ' +\n          'Value should be a React component. ' +\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\n      );\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"direction\" prop has been specified. ' +\n            'Value should be either \"ltr\" or \"rtl\". ' +\n            `\"${direction}\" was specified.`\n        );\n    }\n\n    if (typeof width !== 'number') {\n      throw Error(\n        'An invalid \"width\" prop has been specified. ' +\n          'Grids must specify a number for width. ' +\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\n      );\n    }\n\n    if (typeof height !== 'number') {\n      throw Error(\n        'An invalid \"height\" prop has been specified. ' +\n          'Grids must specify a number for height. ' +\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\n      );\n    }\n  }\n};\n","// @flow\n\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport { cancelTimeout, requestTimeout } from './timer';\nimport { getScrollbarSize, getRTLOffsetType } from './domHelpers';\n\nimport type { TimeoutID } from './timer';\n\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\n\ntype itemSize = number | ((index: number) => number);\n// TODO Deprecate directions \"horizontal\" and \"vertical\"\ntype Direction = 'ltr' | 'rtl' | 'horizontal' | 'vertical';\ntype Layout = 'horizontal' | 'vertical';\n\ntype RenderComponentProps<T> = {|\n  data: T,\n  index: number,\n  isScrolling?: boolean,\n  style: Object,\n|};\ntype RenderComponent<T> = React$ComponentType<$Shape<RenderComponentProps<T>>>;\n\ntype ScrollDirection = 'forward' | 'backward';\n\ntype onItemsRenderedCallback = ({\n  overscanStartIndex: number,\n  overscanStopIndex: number,\n  visibleStartIndex: number,\n  visibleStopIndex: number,\n}) => void;\ntype onScrollCallback = ({\n  scrollDirection: ScrollDirection,\n  scrollOffset: number,\n  scrollUpdateWasRequested: boolean,\n}) => void;\n\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\ntype ItemStyleCache = { [index: number]: Object };\n\ntype OuterProps = {|\n  children: React$Node,\n  className: string | void,\n  onScroll: ScrollEvent => void,\n  style: {\n    [string]: mixed,\n  },\n|};\n\ntype InnerProps = {|\n  children: React$Node,\n  style: {\n    [string]: mixed,\n  },\n|};\n\nexport type Props<T> = {|\n  children: RenderComponent<T>,\n  className?: string,\n  direction: Direction,\n  height: number | string,\n  initialScrollOffset?: number,\n  innerRef?: any,\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\n  innerTagName?: string, // deprecated\n  itemCount: number,\n  itemData: T,\n  itemKey?: (index: number, data: T) => any,\n  itemSize: itemSize,\n  layout: Layout,\n  onItemsRendered?: onItemsRenderedCallback,\n  onScroll?: onScrollCallback,\n  outerRef?: any,\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\n  outerTagName?: string, // deprecated\n  overscanCount: number,\n  style?: Object,\n  useIsScrolling: boolean,\n  width: number | string,\n|};\n\ntype State = {|\n  instance: any,\n  isScrolling: boolean,\n  scrollDirection: ScrollDirection,\n  scrollOffset: number,\n  scrollUpdateWasRequested: boolean,\n|};\n\ntype GetItemOffset = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype GetItemSize = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype GetEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\ntype GetOffsetForIndexAndAlignment = (\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype GetStartIndexForOffset = (\n  props: Props<any>,\n  offset: number,\n  instanceProps: any\n) => number;\ntype GetStopIndexForStartIndex = (\n  props: Props<any>,\n  startIndex: number,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\ntype ValidateProps = (props: Props<any>) => void;\n\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nconst defaultItemKey = (index: number, data: any) => index;\n\n// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nlet devWarningsDirection = null;\nlet devWarningsTagName = null;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = new WeakSet();\n    devWarningsTagName = new WeakSet();\n  }\n}\n\nexport default function createListComponent({\n  getItemOffset,\n  getEstimatedTotalSize,\n  getItemSize,\n  getOffsetForIndexAndAlignment,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange,\n  validateProps,\n}: {|\n  getItemOffset: GetItemOffset,\n  getEstimatedTotalSize: GetEstimatedTotalSize,\n  getItemSize: GetItemSize,\n  getOffsetForIndexAndAlignment: GetOffsetForIndexAndAlignment,\n  getStartIndexForOffset: GetStartIndexForOffset,\n  getStopIndexForStartIndex: GetStopIndexForStartIndex,\n  initInstanceProps: InitInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange: boolean,\n  validateProps: ValidateProps,\n|}) {\n  return class List<T> extends PureComponent<Props<T>, State> {\n    _instanceProps: any = initInstanceProps(this.props, this);\n    _outerRef: ?HTMLDivElement;\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\n\n    static defaultProps = {\n      direction: 'ltr',\n      itemData: undefined,\n      layout: 'vertical',\n      overscanCount: 2,\n      useIsScrolling: false,\n    };\n\n    state: State = {\n      instance: this,\n      isScrolling: false,\n      scrollDirection: 'forward',\n      scrollOffset:\n        typeof this.props.initialScrollOffset === 'number'\n          ? this.props.initialScrollOffset\n          : 0,\n      scrollUpdateWasRequested: false,\n    };\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    constructor(props: Props<T>) {\n      super(props);\n    }\n\n    static getDerivedStateFromProps(\n      nextProps: Props<T>,\n      prevState: State\n    ): $Shape<State> | null {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    }\n\n    scrollTo(scrollOffset: number): void {\n      scrollOffset = Math.max(0, scrollOffset);\n\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n        return {\n          scrollDirection:\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true,\n        };\n      }, this._resetIsScrollingDebounced);\n    }\n\n    scrollToItem(index: number, align: ScrollToAlign = 'auto'): void {\n      const { itemCount, layout } = this.props;\n      const { scrollOffset } = this.state;\n\n      index = Math.max(0, Math.min(index, itemCount - 1));\n\n      // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n      // This is an edge case for lists; normally they only scroll in the dominant direction.\n      let scrollbarSize = 0;\n      if (this._outerRef) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        if (layout === 'vertical') {\n          scrollbarSize =\n            outerRef.scrollWidth > outerRef.clientWidth\n              ? getScrollbarSize()\n              : 0;\n        } else {\n          scrollbarSize =\n            outerRef.scrollHeight > outerRef.clientHeight\n              ? getScrollbarSize()\n              : 0;\n        }\n      }\n\n      this.scrollTo(\n        getOffsetForIndexAndAlignment(\n          this.props,\n          index,\n          align,\n          scrollOffset,\n          this._instanceProps,\n          scrollbarSize\n        )\n      );\n    }\n\n    componentDidMount() {\n      const { direction, initialScrollOffset, layout } = this.props;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentDidUpdate() {\n      const { direction, layout } = this.props;\n      const { scrollOffset, scrollUpdateWasRequested } = this.state;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n              default:\n                const { clientWidth, scrollWidth } = outerRef;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    }\n\n    render() {\n      const {\n        children,\n        className,\n        direction,\n        height,\n        innerRef,\n        innerElementType,\n        innerTagName,\n        itemCount,\n        itemData,\n        itemKey = defaultItemKey,\n        layout,\n        outerElementType,\n        outerTagName,\n        style,\n        useIsScrolling,\n        width,\n      } = this.props;\n      const { isScrolling } = this.state;\n\n      // TODO Deprecate direction \"horizontal\"\n      const isHorizontal =\n        direction === 'horizontal' || layout === 'horizontal';\n\n      const onScroll = isHorizontal\n        ? this._onScrollHorizontal\n        : this._onScrollVertical;\n\n      const [startIndex, stopIndex] = this._getRangeToRender();\n\n      const items = [];\n      if (itemCount > 0) {\n        for (let index = startIndex; index <= stopIndex; index++) {\n          items.push(\n            createElement(children, {\n              data: itemData,\n              key: itemKey(index, itemData),\n              index,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              style: this._getItemStyle(index),\n            })\n          );\n        }\n      }\n\n      // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n      const estimatedTotalSize = getEstimatedTotalSize(\n        this.props,\n        this._instanceProps\n      );\n\n      return createElement(\n        outerElementType || outerTagName || 'div',\n        {\n          className,\n          onScroll,\n          ref: this._outerRefSetter,\n          style: {\n            position: 'relative',\n            height,\n            width,\n            overflow: 'auto',\n            WebkitOverflowScrolling: 'touch',\n            willChange: 'transform',\n            direction,\n            ...style,\n          },\n        },\n        createElement(innerElementType || innerTagName || 'div', {\n          children: items,\n          ref: innerRef,\n          style: {\n            height: isHorizontal ? '100%' : estimatedTotalSize,\n            pointerEvents: isScrolling ? 'none' : undefined,\n            width: isHorizontal ? estimatedTotalSize : '100%',\n          },\n        })\n      );\n    }\n\n    _callOnItemsRendered: (\n      overscanStartIndex: number,\n      overscanStopIndex: number,\n      visibleStartIndex: number,\n      visibleStopIndex: number\n    ) => void;\n    _callOnItemsRendered = memoizeOne(\n      (\n        overscanStartIndex: number,\n        overscanStopIndex: number,\n        visibleStartIndex: number,\n        visibleStopIndex: number\n      ) =>\n        ((this.props.onItemsRendered: any): onItemsRenderedCallback)({\n          overscanStartIndex,\n          overscanStopIndex,\n          visibleStartIndex,\n          visibleStopIndex,\n        })\n    );\n\n    _callOnScroll: (\n      scrollDirection: ScrollDirection,\n      scrollOffset: number,\n      scrollUpdateWasRequested: boolean\n    ) => void;\n    _callOnScroll = memoizeOne(\n      (\n        scrollDirection: ScrollDirection,\n        scrollOffset: number,\n        scrollUpdateWasRequested: boolean\n      ) =>\n        ((this.props.onScroll: any): onScrollCallback)({\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested,\n        })\n    );\n\n    _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        const { itemCount } = this.props;\n        if (itemCount > 0) {\n          const [\n            overscanStartIndex,\n            overscanStopIndex,\n            visibleStartIndex,\n            visibleStopIndex,\n          ] = this._getRangeToRender();\n          this._callOnItemsRendered(\n            overscanStartIndex,\n            overscanStopIndex,\n            visibleStartIndex,\n            visibleStopIndex\n          );\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        const {\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested,\n        } = this.state;\n        this._callOnScroll(\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested\n        );\n      }\n    }\n\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getItemStyle: (index: number) => Object;\n    _getItemStyle = (index: number): Object => {\n      const { direction, itemSize, layout } = this.props;\n\n      const itemStyleCache = this._getItemStyleCache(\n        shouldResetStyleCacheOnItemSizeChange && itemSize,\n        shouldResetStyleCacheOnItemSizeChange && layout,\n        shouldResetStyleCacheOnItemSizeChange && direction\n      );\n\n      let style;\n      if (itemStyleCache.hasOwnProperty(index)) {\n        style = itemStyleCache[index];\n      } else {\n        const offset = getItemOffset(this.props, index, this._instanceProps);\n        const size = getItemSize(this.props, index, this._instanceProps);\n\n        // TODO Deprecate direction \"horizontal\"\n        const isHorizontal =\n          direction === 'horizontal' || layout === 'horizontal';\n\n        const isRtl = direction === 'rtl';\n        const offsetHorizontal = isHorizontal ? offset : 0;\n        itemStyleCache[index] = style = {\n          position: 'absolute',\n          left: isRtl ? undefined : offsetHorizontal,\n          right: isRtl ? offsetHorizontal : undefined,\n          top: !isHorizontal ? offset : 0,\n          height: !isHorizontal ? size : '100%',\n          width: isHorizontal ? size : '100%',\n        };\n      }\n\n      return style;\n    };\n\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\n\n    _getRangeToRender(): [number, number, number, number] {\n      const { itemCount, overscanCount } = this.props;\n      const { isScrolling, scrollDirection, scrollOffset } = this.state;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getStartIndexForOffset(\n        this.props,\n        scrollOffset,\n        this._instanceProps\n      );\n      const stopIndex = getStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollOffset,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || scrollDirection === 'backward'\n          ? Math.max(1, overscanCount)\n          : 1;\n      const overscanForward =\n        !isScrolling || scrollDirection === 'forward'\n          ? Math.max(1, overscanCount)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _onScrollHorizontal = (event: ScrollEvent): void => {\n      const { clientWidth, scrollLeft, scrollWidth } = event.currentTarget;\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollLeft) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        const { direction } = this.props;\n\n        let scrollOffset = scrollLeft;\n        if (direction === 'rtl') {\n          // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              scrollOffset = -scrollLeft;\n              break;\n            case 'positive-descending':\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        scrollOffset = Math.max(\n          0,\n          Math.min(scrollOffset, scrollWidth - clientWidth)\n        );\n\n        return {\n          isScrolling: true,\n          scrollDirection:\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset,\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _onScrollVertical = (event: ScrollEvent): void => {\n      const { clientHeight, scrollHeight, scrollTop } = event.currentTarget;\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollTop) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        const scrollOffset = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        );\n\n        return {\n          isScrolling: true,\n          scrollDirection:\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset,\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _outerRefSetter = (ref: any): void => {\n      const { outerRef } = this.props;\n\n      this._outerRef = ((ref: any): HTMLDivElement);\n\n      if (typeof outerRef === 'function') {\n        outerRef(ref);\n      } else if (\n        outerRef != null &&\n        typeof outerRef === 'object' &&\n        outerRef.hasOwnProperty('current')\n      ) {\n        outerRef.current = ref;\n      }\n    };\n\n    _resetIsScrollingDebounced = () => {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._resetIsScrollingTimeoutId = requestTimeout(\n        this._resetIsScrolling,\n        IS_SCROLLING_DEBOUNCE_INTERVAL\n      );\n    };\n\n    _resetIsScrolling = () => {\n      this._resetIsScrollingTimeoutId = null;\n\n      this.setState({ isScrolling: false }, () => {\n        // Clear style cache after state update has been committed.\n        // This way we don't break pure sCU for items that don't use isScrolling param.\n        this._getItemStyleCache(-1, null);\n      });\n    };\n  };\n}\n\n// NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nconst validateSharedProps = (\n  {\n    children,\n    direction,\n    height,\n    layout,\n    innerTagName,\n    outerTagName,\n    width,\n  }: Props<any>,\n  { instance }: State\n): void => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn(\n          'The innerTagName and outerTagName props have been deprecated. ' +\n            'Please use the innerElementType and outerElementType props instead.'\n        );\n      }\n    }\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn(\n            'The direction prop should be either \"ltr\" (default) or \"rtl\". ' +\n              'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.'\n          );\n        }\n        break;\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"direction\" prop has been specified. ' +\n            'Value should be either \"ltr\" or \"rtl\". ' +\n            `\"${direction}\" was specified.`\n        );\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"layout\" prop has been specified. ' +\n            'Value should be either \"horizontal\" or \"vertical\". ' +\n            `\"${layout}\" was specified.`\n        );\n    }\n\n    if (children == null) {\n      throw Error(\n        'An invalid \"children\" prop has been specified. ' +\n          'Value should be a React component. ' +\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\n      );\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error(\n        'An invalid \"width\" prop has been specified. ' +\n          'Horizontal lists must specify a number for width. ' +\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\n      );\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error(\n        'An invalid \"height\" prop has been specified. ' +\n          'Vertical lists must specify a number for height. ' +\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\n      );\n    }\n  }\n};\n","// @flow\n\nimport createListComponent from './createListComponent';\n\nimport type { Props, ScrollToAlign } from './createListComponent';\n\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\ntype VariableSizeProps = {|\n  estimatedItemSize: number,\n  ...Props<any>,\n|};\n\ntype itemSizeGetter = (index: number) => number;\n\ntype ItemMetadata = {|\n  offset: number,\n  size: number,\n|};\ntype InstanceProps = {|\n  itemMetadataMap: { [index: number]: ItemMetadata },\n  estimatedItemSize: number,\n  lastMeasuredIndex: number,\n|};\n\nconst getItemMetadata = (\n  props: Props<any>,\n  index: number,\n  instanceProps: InstanceProps\n): ItemMetadata => {\n  const { itemSize } = ((props: any): VariableSizeProps);\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\n\n  if (index > lastMeasuredIndex) {\n    let offset = 0;\n    if (lastMeasuredIndex >= 0) {\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\n      let size = ((itemSize: any): itemSizeGetter)(i);\n\n      itemMetadataMap[i] = {\n        offset,\n        size,\n      };\n\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nconst findNearestItem = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  offset: number\n) => {\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\n\n  const lastMeasuredItemOffset =\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(\n      props,\n      instanceProps,\n      lastMeasuredIndex,\n      0,\n      offset\n    );\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(\n      props,\n      instanceProps,\n      Math.max(0, lastMeasuredIndex),\n      offset\n    );\n  }\n};\n\nconst findNearestItemBinarySearch = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  high: number,\n  low: number,\n  offset: number\n): number => {\n  while (low <= high) {\n    const middle = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemMetadata(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nconst findNearestItemExponentialSearch = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  index: number,\n  offset: number\n): number => {\n  const { itemCount } = props;\n  let interval = 1;\n\n  while (\n    index < itemCount &&\n    getItemMetadata(props, index, instanceProps).offset < offset\n  ) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(\n    props,\n    instanceProps,\n    Math.min(index, itemCount - 1),\n    Math.floor(index / 2),\n    offset\n  );\n};\n\nconst getEstimatedTotalSize = (\n  { itemCount }: Props<any>,\n  { itemMetadataMap, estimatedItemSize, lastMeasuredIndex }: InstanceProps\n) => {\n  let totalSizeOfMeasuredItems = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nconst VariableSizeList = createListComponent({\n  getItemOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata(props, index, instanceProps).offset,\n\n  getItemSize: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.itemMetadataMap[index].size,\n\n  getEstimatedTotalSize,\n\n  getOffsetForIndexAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps,\n    scrollbarSize: number\n  ): number => {\n    const { direction, height, layout, width } = props;\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const itemMetadata = getItemMetadata(props, index, instanceProps);\n\n    // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n    const estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n\n    const maxOffset = Math.max(\n      0,\n      Math.min(estimatedTotalSize - size, itemMetadata.offset)\n    );\n    const minOffset = Math.max(\n      0,\n      itemMetadata.offset - size + itemMetadata.size + scrollbarSize\n    );\n\n    if (align === 'smart') {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getStartIndexForOffset: (\n    props: Props<any>,\n    offset: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem(props, instanceProps, offset),\n\n  getStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollOffset: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { direction, height, itemCount, layout, width } = props;\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const itemMetadata = getItemMetadata(props, startIndex, instanceProps);\n    const maxOffset = scrollOffset + size;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\n    const { estimatedItemSize } = ((props: any): VariableSizeProps);\n\n    const instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredIndex: -1,\n    };\n\n    instance.resetAfterIndex = (\n      index: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instanceProps.lastMeasuredIndex = Math.min(\n        instanceProps.lastMeasuredIndex,\n        index - 1\n      );\n\n      // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: false,\n\n  validateProps: ({ itemSize }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error(\n          'An invalid \"itemSize\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default VariableSizeList;\n"],"names":["FullDateInterface","constructor","date","this","fullDate","getTimeInSec","dateString","substring","timeString","yyyy","parseInt","mm","length","undefined","dd","isNaN","Error","dateJS","Date","HH","MM","SS","fractionalStr","FFFFFF","Math","pow","timeInSec","getTime","getTimeInMicroSec","combineDateTime","time","hours","padStart","minutes","seconds","month","day","fractionalSeconds","padEnd","year","parseDA","d","m","y","daysInMonth","parseTM","hh","ss","ffffff","dateTimeToFullDateInterface","dateTime","calculateDecayCorrection","instances","RadionuclideTotalDose","RadionuclideHalfLife","RadiopharmaceuticalStartDateTime","RadiopharmaceuticalStartTime","SeriesDate","scanTimes","SeriesTime","GEPrivatePostInjectionDateTime","results","Array","seriesDateTime","earliestAcquisitionDateTime","timeError","forEach","instance","AcquisitionDate","AcquisitionTime","acquisitionDateTime","fill","calculateScanTimes","startTime","input","calculateStartTime","map","_","index","decayTimeInSec","deepEquals","a","b","isArray","every","val","calculateSUVScalingFactors","CorrectedImage","Units","PhilipsPETPrivateGroup","PatientWeight","PatientSex","PatientSize","includes","DecayCorrection","decayCorrectionArray","weightInGrams","value","hasValidSUVScaleFactor","SUVScaleFactor","hasValidActivityConcentrationScaleFactor","ActivityConcentrationScaleFactor","JSON","stringify","suvbsaFactor","suvlbmFactor","suvlbmJenmaFactor","console","warn","inputs","calculateSUVbsaScalingFactor","suvlbmInputs","LBM","weightSizeFactor","calculateSUVlbmScalingFactor","bodyMassIndex","calculateSUVlbmJanmahasatianScalingFactor","result","factors","suvbw","suvbsa","suvlbm","suvlbmJanma","stringToUint8Array","str","arr","Uint8Array","i","j","charCodeAt","containsToken","message","token","offset","findToken","maxSearchLength","searchLength","min","multipartEncode","datasets","boundary","s4","floor","random","toString","guid","contentTypeString","header","footer","headerArray","footerArray","headerLength","footerLength","contentArrays","datasetBuffer","contentArray","contentLength","multipartArray","set","position","data","buffer","multipartDecode","response","ArrayBuffer","isView","separator","headerIndex","itemLimit","String","fromCharCode","uint8ArrayToString","boundaryString","parts","split","substr","identifyBoundary","boundaryIndex","boundaryLength","components","headerTokenIndex","slice","push","isObject","obj","isEmptyObject","Object","keys","getFirstResult","MEDIATYPES","DICOM","DICOM_JSON","OCTET_STREAM","PDF","JPEG","PNG","debugLog","api","DICOMwebClient","options","baseURL","url","error","username","password","qidoURLPrefix","qidoURL","wadoURLPrefix","wadoURL","stowURLPrefix","stowURL","singlepart","requestHooks","headers","errorInterceptor","verbose","setDebug","debug","debugLevel","debugLogFunction","log","method","Promise","resolve","reject","request","XMLHttpRequest","open","responseType","key","setRequestHeader","functions","userHeaders","onloadstart","onloadend","onreadystatechange","readyState","status","contentType","getResponseHeader","indexOf","progressCallback","onprogress","isValid","requestHook","areValidRequestHooks","combinedHeaders","assign","metadata","pipedRequest","args","reduce","props","fn","withCredentials","send","_httpRequest","params","urlWithQueryParams","_parseQueryParameters","Accept","_httpGet","mediaTypes","_buildAcceptHeaderFieldValue","byteRange","supportedMediaTypes","Range","_buildRangeHeaderFieldValue","_buildMultipartAcceptHeaderFieldValue","defaultMediaType","acceptableMediaTypes","mediaType","values","_httpPost","queryParams","_httpGetApplicationJson","studyInstanceUID","seriesInstanceUID","transferSyntax","sopInstanceUID","paramString","join","frameNumbers","_httpGetMultipartApplicationOctetStream","_getSharedMediaTypes","commonMediaType","_getCommonMediaType","startsWith","_httpGetMultipartImage","_httpGetMultipartVideo","_httpGetImage","_httpGetVideo","_httpGetText","_httpGetApplicationPdf","_httpGetMultipartApplicationDicom","then","BulkDataURI","e","queryString","encodeURIComponent","sepIndex","mediaTypeType","_assertMediaTypeIsValid","item","fieldValueParts","transferSyntaxUID","fieldValue","flat","endsWith","expectedMediaTypes","actualType","_parseMediaType","expectedMediaType","expectedType","types","Set","type","add","from","sharedMediaTypes","now","performance","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","requestAnimationFrame","tick","call","size","getScrollbarSize","recalculate","div","document","createElement","style","width","height","overflow","body","appendChild","offsetWidth","clientWidth","removeChild","cachedRTLResult","getRTLOffsetType","outerDiv","outerStyle","direction","innerDiv","innerStyle","scrollLeft","defaultItemKey","createListComponent","getItemOffset","getEstimatedTotalSize","getItemSize","getOffsetForIndexAndAlignment","getStartIndexForOffset","getStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_instanceProps","_outerRef","_resetIsScrollingTimeoutId","state","isScrolling","scrollDirection","scrollOffset","initialScrollOffset","scrollUpdateWasRequested","_callOnItemsRendered","memoizeOne","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","itemSize","layout","itemStyleCache","_getItemStyleCache","hasOwnProperty","isHorizontal","isRtl","offsetHorizontal","left","right","top","__","___","_onScrollHorizontal","event","currentTarget","scrollWidth","setState","prevState","max","_resetIsScrollingDebounced","_onScrollVertical","clientHeight","scrollHeight","scrollTop","_outerRefSetter","ref","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps","scrollTo","scrollToItem","align","itemCount","scrollbarSize","componentDidMount","_callPropsCallbacks","componentDidUpdate","componentWillUnmount","render","children","className","innerRef","innerElementType","innerTagName","itemData","itemKey","outerElementType","outerTagName","useIsScrolling","_getRangeToRender","startIndex","stopIndex","items","estimatedTotalSize","WebkitOverflowScrolling","willChange","pointerEvents","overscanCount","overscanBackward","overscanForward","PureComponent","defaultProps","getItemMetadata","instanceProps","itemMetadataMap","lastMeasuredIndex","itemMetadata","findNearestItemBinarySearch","high","low","middle","currentOffset","findNearestItemExponentialSearch","interval","estimatedItemSize","totalSizeOfMeasuredItems","VariableSizeList","maxOffset","minOffset","round","findNearestItem","resetAfterIndex","shouldForceUpdate","forceUpdate"],"sourceRoot":""}